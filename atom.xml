<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>何谐写字的地方</title>
  
  <subtitle>技术生活随笔</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://hexiecs.com/"/>
  <updated>2019-09-06T02:48:50.652Z</updated>
  <id>http://hexiecs.com/</id>
  
  <author>
    <name>何谐</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++11新特性学习</title>
    <link href="http://hexiecs.com/2017/08/19/c++%2011%20%E6%96%B0%E7%89%B9%E6%80%A7%E5%AD%A6%E4%B9%A0/"/>
    <id>http://hexiecs.com/2017/08/19/c++ 11 新特性学习/</id>
    <published>2017-08-19T14:51:09.000Z</published>
    <updated>2019-09-06T02:48:50.652Z</updated>
    
    <content type="html"><![CDATA[<p>some useful features I used.</p><a id="more"></a><h1 id="lamda表达式"><a href="#lamda表达式" class="headerlink" title="lamda表达式"></a>lamda表达式</h1><ol><li><strong>匿名函数对象</strong>  ,也叫闭包</li><li>语法：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[capture](params) -&gt; ret &#123;body&#125;</span><br><span class="line">[capture](params)&#123;body&#125;</span><br><span class="line">[capture]&#123;body&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h1><p>nothing to say</p><h1 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h1><p>可以得到括号内表达式的类型，方便变量定义，如果在定义函数指针时。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">decltype(&amp;myfunc) pfunc = 0;</span><br><span class="line">typedef decltype(&amp;A::func) type;</span><br></pre></td></tr></table></figure><h1 id="统一用-初始化"><a href="#统一用-初始化" class="headerlink" title="统一用{}初始化"></a>统一用{}初始化</h1><p>nothing to say， useless</p><h1 id="delete-和-default"><a href="#delete-和-default" class="headerlink" title="delete 和 default"></a>delete 和 default</h1><p>在函数声明的后面加上 <code>= delete</code>,编译器不会产生这个函数的代码，而加上<code>=default</code>,编译器会产生一个默认的。比如，当想让一个类禁止拷贝操作时，delete就很有用。当自己定义了构造函数，但又想编译器生成一个默认的时，default也很有用。</p><h1 id="nullptr"><a href="#nullptr" class="headerlink" title="nullptr"></a>nullptr</h1><p>nothing to say，新标准中请用nullptr代替NULL</p><h1 id="右值引用和move"><a href="#右值引用和move" class="headerlink" title="右值引用和move"></a>右值引用和move</h1><p>请看这篇文章：<br><a href="https://www.ibm.com/developerworks/cn/aix/library/1307_lisl_c11/index.html" target="_blank" rel="noopener">右值引用与转移语义</a></p><h1 id="线程库"><a href="#线程库" class="headerlink" title="线程库"></a>线程库</h1><p>//Todo:c++11多线程另开文章讲解</p><h1 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h1><p>shared_ptr:实现了引用计数,当引用计数为0时，才释放对象<br>unique_ptr:同一时刻，只能有一个指针指向该对象。因此，它实现的是移动语义，而不是拷贝语义。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;some useful features I used.&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++" scheme="http://hexiecs.com/categories/C/"/>
    
    
      <category term="C++11" scheme="http://hexiecs.com/tags/C-11/"/>
    
  </entry>
  
  <entry>
    <title>C++对象初始化</title>
    <link href="http://hexiecs.com/2017/03/26/C++%20object%20initialize/"/>
    <id>http://hexiecs.com/2017/03/26/C++ object initialize/</id>
    <published>2017-03-26T13:41:00.000Z</published>
    <updated>2019-09-06T02:48:50.651Z</updated>
    
    <content type="html"><![CDATA[<p>c++初始化对象的几种方式</p><a id="more"></a><h2 id="列表初始化"><a href="#列表初始化" class="headerlink" title="列表初始化"></a>列表初始化</h2><p>形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[new] T [object] &#123; arg1, arg2, ... &#125;;</span><br></pre></td></tr></table></figure><ul><li>如果T是aggregate类型，那么就用arg参数逐个初始化T的成员，如果T的成员个数大于arg参数的数目，剩下的成员执行值初始化。</li><li>如果T不是aggregate类型，那么编译器查找最匹配list参数的T的构造函数。</li></ul><h2 id="值初始化和默认初始化"><a href="#值初始化和默认初始化" class="headerlink" title="值初始化和默认初始化"></a>值初始化和默认初始化</h2><p>值初始化形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[new] T [object] &#123;&#125;;</span><br></pre></td></tr></table></figure><p>默认初始化形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[new] T object;</span><br></pre></td></tr></table></figure><p>二者区别：</p><ul><li>只要使用了括号（圆括号或花括号），就是值初始化。可以简单理解为括号提醒编译器你想要用某个值赋给对象。没有使用括号，就是默认初始化。可以简单理解成，你不加任何东西，编译器就会使用默认的行为。</li><li>默认初始化：总是试图使用默认构造函数初始化对象。但是它对于POD类型则不这么做。比如：C基本类型，聚合类型，POD类型的数组。C语言的struct以及基本类型如果不初始化也是随机的值，和这个POD类型在C++类似。我们可以简单理解为：总使用默认构造函数，同时兼容C。值初始化：有用户定义构造函数，就执行用户定义的构造函数，否则都使用零初始化。</li></ul><h2 id="直接初始化"><a href="#直接初始化" class="headerlink" title="直接初始化"></a>直接初始化</h2><p>直接使用构造函数进行初始化。</p><h2 id="拷贝初始化"><a href="#拷贝初始化" class="headerlink" title="拷贝初始化"></a>拷贝初始化</h2><p>使用等号，要求编译器将右侧运算对象拷贝到正在创建的对象中，调用拷贝构造函数。</p><p>参考资料：<br><a href="https://www.zhihu.com/question/36735960" target="_blank" rel="noopener">https://www.zhihu.com/question/36735960</a><br><a href="http://vbill.github.io/2016/11/14/cpp-init/" target="_blank" rel="noopener">http://vbill.github.io/2016/11/14/cpp-init/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;c++初始化对象的几种方式&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++" scheme="http://hexiecs.com/categories/C/"/>
    
    
      <category term="c++" scheme="http://hexiecs.com/tags/c/"/>
    
  </entry>
  
</feed>
