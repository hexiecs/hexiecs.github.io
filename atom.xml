<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>何谐写字的地方</title>
  
  <subtitle>技术生活随笔</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://hexiecs.com/"/>
  <updated>2020-02-09T14:02:52.405Z</updated>
  <id>http://hexiecs.com/</id>
  
  <author>
    <name>何谐</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode-Search</title>
    <link href="http://hexiecs.com/2020/01/29/LeetCode/LeetCode-Search/"/>
    <id>http://hexiecs.com/2020/01/29/LeetCode/LeetCode-Search/</id>
    <published>2020-01-29T14:09:06.000Z</published>
    <updated>2020-02-09T14:02:52.405Z</updated>
    
    <content type="html"><![CDATA[<p>The Search Problems in LeetCode.</p><a id="more"></a><h2 id="Remove-Invalid-Parentheses"><a href="#Remove-Invalid-Parentheses" class="headerlink" title="Remove Invalid Parentheses"></a><a href="https://leetcode.com/problems/remove-invalid-parentheses/" target="_blank" rel="noopener">Remove Invalid Parentheses</a></h2><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>Remove the minimum number of parentheses to make the string valid, return all possible valid result.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>We know how to check if a string is valid, which is using a counter to record the open and close parentheses we encounter and whenever the close parentheses are more than open, it is invalid. After the process, if the counter is larger than 0, it is also invalid. But how to generate all the possible results? We use dfs search to do this. </p><ul><li>iterate from left to right, and if the close parentheses are more than the open parentheses, we could remove any of the parentheses before current position (inclusively), which generate all possible results before current position.</li><li>After the removal, we recursively call the dfs function to process the rest of the string, so we need a start of iteration position parameter in the dfs function.</li><li>in case we delete duplicate parentheses in the dfs, we need to add the start of removal position in dfs function parameter too. If we delete a parentheses at position i, then in the following dfs calling we should only delete parentheses after position i.</li><li>If there are multiple contiguous parentheses, delete any one of them will generate the same result, so we always delete the first one of them and skip others.</li><li>When we finish above iteration, we have only removed the close parentheses, so the open ones are possibly more than the close too, so we need to process open parentheses similarly to the close ones. We can do this cleverly by reversing the string and reversing the open and close parentheses when we check.</li></ul><h2 id="Decode-String"><a href="#Decode-String" class="headerlink" title="Decode String"></a><a href="https://leetcode.com/problems/decode-string/" target="_blank" rel="noopener">Decode String</a></h2><h3 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h3><p>Given an encoded string, return its decoded string.</p><p>The encoding rule is: k[encoded_string], where the encoded string inside the square brackets is being repeated exactly k times.  For example, s = “3[a]2[bc]”, return “aaabcbc”. s = “3[a2[c]]”, return “accaccacc”.</p><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><p>We can solve this by dfs. When we encounter left bracket, we can calculate the string inside the brackets recursively. So every time we iterate the string until we encounter the right brackets. We append to current result for any English  character, get the number for any digit character, repeat the responding times for following recursive call result.</p><h2 id="Find-All-Anagrams-in-a-String"><a href="#Find-All-Anagrams-in-a-String" class="headerlink" title="Find All Anagrams in a String"></a><a href="https://leetcode.com/problems/find-all-anagrams-in-a-string/" target="_blank" rel="noopener">Find All Anagrams in a String</a></h2><h3 id="Description-2"><a href="#Description-2" class="headerlink" title="Description"></a>Description</h3><p>Given a string s and a non-empty string p, find all the start indices of p’s anagrams in s.</p><h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><p>This is a sliding window problem. We can use a map to store all the characters of p because we want to find the anagrams so the order of characters don’t matter. We use begin and end pointers to represent the sliding window and a counter to represent the number of characters of p that is still remained to be checked in s, which is initiated with the map’s size. The sliding window problem can be solved with following template:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">map&lt;int, int&gt; m;</span><br><span class="line">for (int i = 0; i &lt; p.size(); i++) &#123;</span><br><span class="line">m[p[i]]++;</span><br><span class="line">&#125;</span><br><span class="line">int begin = 0, end = 0;</span><br><span class="line">int counter = m.size();</span><br><span class="line">while (end &lt; s.size()) &#123;</span><br><span class="line">if (m[s[end++]]-- (some condition)) &#123;</span><br><span class="line">modify counter;</span><br><span class="line">&#125;</span><br><span class="line">while (counter == 0) &#123;</span><br><span class="line">add or update the result</span><br><span class="line">if (m[s[begin++]]++ (some condition)) &#123;</span><br><span class="line">modify counter;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;The Search Problems in LeetCode.&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://hexiecs.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://hexiecs.com/tags/LeetCode/"/>
    
      <category term="Search" scheme="http://hexiecs.com/tags/Search/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-Heap</title>
    <link href="http://hexiecs.com/2020/01/26/LeetCode/LeetCode-Heap/"/>
    <id>http://hexiecs.com/2020/01/26/LeetCode/LeetCode-Heap/</id>
    <published>2020-01-26T07:41:37.000Z</published>
    <updated>2020-02-04T05:21:08.482Z</updated>
    
    <content type="html"><![CDATA[<p>The Heap Problems in LeetCode</p><a id="more"></a><h2 id="Find-Median-from-Data-Stream"><a href="#Find-Median-from-Data-Stream" class="headerlink" title="Find Median from Data Stream"></a><a href="https://leetcode.com/problems/find-median-from-data-stream/" target="_blank" rel="noopener">Find Median from Data Stream</a></h2><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>Median is the middle value in an ordered integer list. If the size of the list is even，there is no middle value, so the median is the mean of the two middle value.</p><p>Design a data structure that supports the following two operation:</p><ul><li>void addNum(int num) - Add a integer from the data stream to the data structure</li><li>void findMedian() - Return the median of all elements so far.</li></ul><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>Use two heaps to maintain the smaller and larger half part of the integers, and the smaller heap is a max-heap and the larger heap is a min-heap. We  can use priority_queue in STL as heaps. To maintain that, when an new integer needs to be added, we should know which heap it should be added. Since the two heaps are the half part of the integers, so the size difference of them shouldn’t exceed more than 1, we can let the smaller part size always larger or equal than the larger part. We can do following logics to maintain the two heaps:</p><ul><li>If the two heaps are of equal size, we want the new integer added in the smaller one. So we check it with the smallest value of the larger heap, if it’s smaller than the value, it can be safely added to the smaller heap because it won’t break the requirement that all integers in the larger heap are larger than all integers in smaller heap. If it’s larger than the value, the value should be poped from the larger one to the smaller one and the new integer should be added to the larger one.</li><li>If the two heaps are of different size, which means the smaller one’s size is larger than the larger one by one. So we want the new integer to be added to the larger heap. If the integer is larger than the largest value of the smaller heap, it can be safely added to the larger heap, otherwise the largerst value of the smaller heap should be poped out from the smaller heap to the larger heap and the new integer should be added to the smaller heap.</li></ul><p>Having the above two heaps, we can easily get the median at any time. If the smaller heap’s size is equal to the larger heap, we use the mean of their top value, otherwise we use the top of the smaller heap.</p><h2 id="Top-K-Frequent-Elements"><a href="#Top-K-Frequent-Elements" class="headerlink" title="Top K Frequent Elements"></a><a href="https://leetcode.com/problems/top-k-frequent-elements/" target="_blank" rel="noopener">Top K Frequent Elements</a></h2><h3 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h3><p>Given an array of integers, return k most frequent integers.</p><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><p>We can relate this to the k largest number problem, which is solved by priority queue. But numbers should be sorted by frequency in this problem. So we use a map to calculate each number’s frequency, and construct the priority using the map. The compare function of the priority queue is to compare by frequency. The priority heap is a min-heap used to save the largest k elements and whenever its size is larger than k we can pop the top one since it’s the smallest among all.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;The Heap Problems in LeetCode&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://hexiecs.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://hexiecs.com/tags/LeetCode/"/>
    
      <category term="Heap" scheme="http://hexiecs.com/tags/Heap/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-Binary Search</title>
    <link href="http://hexiecs.com/2020/01/25/LeetCode/LeetCode-Binary-Search/"/>
    <id>http://hexiecs.com/2020/01/25/LeetCode/LeetCode-Binary-Search/</id>
    <published>2020-01-25T06:06:21.000Z</published>
    <updated>2020-01-29T03:07:36.367Z</updated>
    
    <content type="html"><![CDATA[<p>The binary search problems in LeetCode.</p><a id="more"></a><h2 id="Search-a-2D-Matrix-II"><a href="#Search-a-2D-Matrix-II" class="headerlink" title="Search a 2D Matrix II"></a><a href="https://leetcode.com/problems/search-a-2d-matrix-ii/" target="_blank" rel="noopener">Search a 2D Matrix II</a></h2><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>search for a value in an m x n matrix, the matrix has following properties:</p><ol><li>Integers in each row are sorted in ascending order from left to right.</li><li>Integers in each column are sorted in ascending order from top to bottom.</li></ol><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><h4 id="O-m-log-n"><a href="#O-m-log-n" class="headerlink" title="O(m*log(n))"></a>O(m*log(n))</h4><p>We can do a binary search in each row to find the value, so the time complexity is O(m * log(n))</p><h4 id="O-m-n"><a href="#O-m-n" class="headerlink" title="O(m + n)"></a>O(m + n)</h4><p>we start from the top right corner integers, noting that this integers has the property that every integer behind it is larger than it and every integer at the left side of it is less than it. If the target value is larger than the integer, then all integers on that row are impossible to be the target since they are all less than the integer, so we can move to next row. If the target value is less than the integer, then all integers in that column are impossible to be the target since they are all larger than the integer, so we can move to the next left column. By this way, we need to move at most m + n times, so the time complexity is O(m + n).</p><h2 id="Longest-Increasing-Subsequence"><a href="#Longest-Increasing-Subsequence" class="headerlink" title="Longest Increasing Subsequence"></a><a href="https://leetcode.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">Longest Increasing Subsequence</a></h2><h3 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h3><p>Given an unsorted array of integers, find the length of longest increasing subsequence.</p><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><p>There are two ways of solving the problem: dp or binary search. The Dp solution is using a dp array that dp[i] represents the length of subsequence  that ends with nums[i]. The binary search solution is a little tricky. we use a tail array that tails[i] representes the smallest last element of subsequences with length i + 1. For example, the array is [4, 5, 6 ,3]. the tail[0] = 3, tail[1] = 5, tail[2] = 6. We need to notice that the tail array is ascending To maintain the tail array, we’ll do following binary search steps:</p><ol><li>If nums[i] is larger than all tails elements, then tails push back the nums[i] to represent that the size of longest increasing subsequence increases by 1 and its tail element is nums[i].</li><li>then nums[i] &lt;= tails[i], update tails[i]  = nums[i] because we can append nums[i] to the end of tails[i-1] to make a length i+1 and nums[i] is smaller.</li></ol><p>After iterating the nums array, the size of tail array is the answer.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;The binary search problems in LeetCode.&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://hexiecs.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://hexiecs.com/tags/LeetCode/"/>
    
      <category term="Binary Search" scheme="http://hexiecs.com/tags/Binary-Search/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-Graph</title>
    <link href="http://hexiecs.com/2020/01/20/LeetCode/LeetCode-Graph/"/>
    <id>http://hexiecs.com/2020/01/20/LeetCode/LeetCode-Graph/</id>
    <published>2020-01-20T00:16:34.000Z</published>
    <updated>2020-01-20T00:45:15.067Z</updated>
    
    <content type="html"><![CDATA[<p>The Graph Problems in LeetCode</p><a id="more"></a><h2 id="Course-Schedule"><a href="#Course-Schedule" class="headerlink" title="Course Schedule"></a><a href="https://leetcode.com/problems/course-schedule/" target="_blank" rel="noopener">Course Schedule</a></h2><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>There are n courses you have to take, labeled from 0 to n-1. Some courses may have prerequisites, for example, course 0 must be taken after couse 1, which is expressed as a pair [0, 1].</p><p>Given the total number of courses and a list of prerequisites, determine whether it possible to finish all courses?</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>This is actually equal to determine whether a graph has a cycle or whether a list of nodes can be topology sorted. There are bfs or dfs ways to do this.</p><ol><li>BFS: Calculate the in degrees of every courses. Then take the nodes that have zero in degrees at a time. Every times a node is taken, subtract the degree of nodes connected by one. Loop this process until all the nodes are taken which is true or there are not any nodes whose in degree is zero which is false. Since we should not taken same nodes for multiple times, to avoid extra space, we just subtract the zero in degree of the taken nodes by one to make it become -1 so it won’t be taken later.</li><li>DFS: Calculate the in degrees of every courses. We divide all the nodes to unvisited and visited nodes. We iterate all the nodes and find the unvisited nodes to visit. In each visit, we start from the node and keep visiting all its neighbors. If at a time we visit a node that has been visited, then there is a cycle. Note that we need an bool array to record which nodes have been visited so we needn’t visit it later. We also need an bool array in each visit path (visit path means start from a unvisited node, and keep visiting its neighbors until reach a cycle or every possibly nodes have been reached. ) to determine a cycle, so it should be reset true before one node is visited and reset false after all its neighbors have been visited because it’s only related to a single visit path and shouldn’t influence another visit path.  </li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;The Graph Problems in LeetCode&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://hexiecs.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://hexiecs.com/tags/LeetCode/"/>
    
      <category term="Graph" scheme="http://hexiecs.com/tags/Graph/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-Queue</title>
    <link href="http://hexiecs.com/2020/01/17/LeetCode/LeetCode-Queue/"/>
    <id>http://hexiecs.com/2020/01/17/LeetCode/LeetCode-Queue/</id>
    <published>2020-01-17T00:34:52.000Z</published>
    <updated>2020-01-17T01:00:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>Problems solved by queue.</p><a id="more"></a><h2 id="Sliding-Window-Maximum"><a href="#Sliding-Window-Maximum" class="headerlink" title="Sliding Window Maximum"></a><a href="https://leetcode.com/problems/sliding-window-maximum/" target="_blank" rel="noopener">Sliding Window Maximum</a></h2><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>Given an array of integers, you have a window size K moving from the very left to the very right, get the maximum number of every window.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>Use a monotonic queue to store the integers of current window in descending order, so we can get the maximum number by the head of the queue, which is O(1). To maintain the queue, every time we push an integer to the queue, we can pop_back all integers that are less than current integer, which making the queue in a descending order. We can do this way because current integer is larger by the poped integers and current position is also larger than the poped positions, so if current integers and poped integers appear at the same time in a window, the poped integers can’t be the largest one. Besides, since the window moves the integers outside in a left to right order, we need to record how many integers are poped back by current integers. When current integer needs to be moved outside from the window, we should move the integers it poped back outside first because those integers’ position is less than current integer’s, so we just decrease the count of the integers poped back by current integer by one if current integer is being moved outside. If the count has become zero, it is the time to pop current integer.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Problems solved by queue.&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://hexiecs.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://hexiecs.com/tags/LeetCode/"/>
    
      <category term="Queue" scheme="http://hexiecs.com/tags/Queue/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-Stack</title>
    <link href="http://hexiecs.com/2019/12/29/LeetCode/LeetCode-Stack/"/>
    <id>http://hexiecs.com/2019/12/29/LeetCode/LeetCode-Stack/</id>
    <published>2019-12-29T07:42:15.000Z</published>
    <updated>2020-02-12T13:43:21.839Z</updated>
    
    <content type="html"><![CDATA[<p>The Stack Problems in LeetCode</p><a id="more"></a><h2 id="Basic-Calculator"><a href="#Basic-Calculator" class="headerlink" title="Basic Calculator"></a><a href="https://leetcode.com/problems/basic-calculator/" target="_blank" rel="noopener">Basic Calculator</a></h2><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>Given a string of non-negative numbers, ‘+’, ‘-‘ and parentheses, calculate its value. You can assume the expression is valid.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>Since there are parentheses in the expression, we usually need a stack to implement it. When we encounter a ‘(‘, we push numbers or operators onto stack, and pop them when we encounter a ‘)’. When we calculate numbers inside a pair of parentheses, it is easy to iterate from left to right and process the sign of each number and finally get the value. However, after we complete the value of a pair of parentheses expression, the sign of the value is non obvious. Take the expression ‘1 - (2 - 3)’ for example, when we get the result of (2 - 3), how can we know it’s negtive or positive? So there must be somewhere we store the minus sign in this example. We may notice that the minus sign is used after the parentheses expression is finished, which is at the same time as the number 1. The key idea is that we should save the sign and current calculated numbers in stacks when we encounter a left ‘(‘ which means we need to calculate another ‘current value’ so the existed current value need to be saved right now and be poped when the another value is finished.</p><h2 id="Daily-Temperatures"><a href="#Daily-Temperatures" class="headerlink" title="Daily Temperatures"></a><a href="https://leetcode.com/problems/daily-temperatures/" target="_blank" rel="noopener">Daily Temperatures</a></h2><h3 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h3><p>Given an integer array, for each integer find the first right side integer larger than it.</p><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><p>Use a monotonous stack which maintains the smallest integers on the top. For each integer, we compare it with the top of the stack. If the integer is less, we push it to the stack. Otherwise, we pop the top of the stack until there is some integer larger than the integer. For each poped out integer, the current compared integer is exactly the first larger integer on the right side.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;The Stack Problems in LeetCode&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://hexiecs.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://hexiecs.com/tags/LeetCode/"/>
    
      <category term="Stack" scheme="http://hexiecs.com/tags/Stack/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-Divide-And-Conquer</title>
    <link href="http://hexiecs.com/2019/12/29/LeetCode/LeetCode-Divide-And-Conquer/"/>
    <id>http://hexiecs.com/2019/12/29/LeetCode/LeetCode-Divide-And-Conquer/</id>
    <published>2019-12-29T03:04:16.000Z</published>
    <updated>2020-01-25T02:56:23.008Z</updated>
    
    <content type="html"><![CDATA[<p>The Divide And Conquer Problems in LeetCode.</p><a id="more"></a><h2 id="Unique-Binary-Search-Trees"><a href="#Unique-Binary-Search-Trees" class="headerlink" title="Unique Binary Search Trees"></a><a href="https://leetcode.com/problems/unique-binary-search-trees/" target="_blank" rel="noopener">Unique Binary Search Trees</a></h2><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>Given n, find out how many different ways to construct a binary search tree using numbers 1…n</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>We can calculate the answer by using 1…n each as the root node, and sum them up is the final result. Suppose we are using number i as the root node, then its left subtree is using number 1…i - 1 and its right subtree is using number i+1…n. And if we calculate the distinct ways of left subtree and distinct ways of right subtree, then we get the result of using number i as a root node by multiply the two numbers. So this is actually a dynamic programming problem, If we define G(n) as the final answer of the problem, then G(n) = Sum(G(i - 1) * G(n - i)), where i ranges from 1 to n and G(i - 1) is the result of left subtree and G(n - i) is the result of right subtree because the answer of (i+1…n) is obviously equal to the answer of (1…n-i), besides, bottom case if that G(0) = G(1) = 1. Giving this formula, we can get the answer either by iterative ways(double for loop, calculate G(2) first) or recursive ways by memorizing search. </p><h2 id="Unique-Binary-Search-Trees-II"><a href="#Unique-Binary-Search-Trees-II" class="headerlink" title="Unique Binary Search Trees II"></a><a href="https://leetcode.com/discuss/general-discussion/459286/Best-Posts-of-2019" target="_blank" rel="noopener">Unique Binary Search Trees II</a></h2><h3 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h3><p>Generate all the unique BSTs that contain values range from 1 to n, which is the variant of the previous problem. </p><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><p>Since this problem needs to generate all the specific BSTs, counting the number of BST is not enough but the idea is similar. In the previous problem, when we determine the number of BSTs with a sequence of 1..n, we divide it to left part and right part by choosing a root node and multiply the both to get a final answer. Similarly, when we generate BSTs with a number sequence of 1…n, we choose any number as a root node, and generate left tree and right tree recursively. After that, the current root node’s left child can be any one root node of left trees, and right child can be any root node of right trees of course. In code details, we need to solve the problem in a recursive way (iterative way can be very difficult to implement), and the parameters of recursive function is the start and end number of the sequence. We can choose any number belonging to the range and divide it to two part and process it recursively. The bottom case is that when start is larger than end, which shows that there is not any valid tree, instead of returning a empty result directly, we need to add a NULL pointer to the result vector, which can be used by the upper root node to set its child pointers.   </p><h2 id="Different-Ways-to-Add-Parentheses"><a href="#Different-Ways-to-Add-Parentheses" class="headerlink" title="Different Ways to Add Parentheses"></a><a href="https://leetcode.com/problems/different-ways-to-add-parentheses/" target="_blank" rel="noopener">Different Ways to Add Parentheses</a></h2><h3 id="Description-2"><a href="#Description-2" class="headerlink" title="Description"></a>Description</h3><p>Given a string of numbers and operators, you can add parentheses to group numbers and operators, return all the possible results from computing all the possible ways to group numbers and operators. The operators contain ‘+’, ‘-‘ and ‘*’.</p><h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><p>The key idea is that all the possible ways to group numbers and operators are all the cases that we use one operator as the last operator to be operated. No matter how we group them, there must be one operator to be operated at last, which equals to we add parentheses to the left part and  right part of it. So if we iterate over all the operators and treat any of them as the last one, we get all the possible ways. So the solutions is very similar to previous problem, we iterate the string until we meet an operator, and we calculate the left part and right part of the operator, which is a substring that can be calculated recursively. When we get the both part calculated, we combine them to get the answer of current operator, then we iterate to the next operator. To avoid calculating a substring for multiple times, we memorize the result of a substring after we calculate it. </p><h2 id="Kth-Largest-Element-in-an-Array"><a href="#Kth-Largest-Element-in-an-Array" class="headerlink" title="Kth Largest Element in an Array"></a><a href="https://leetcode.com/problems/kth-largest-element-in-an-array/" target="_blank" rel="noopener">Kth Largest Element in an Array</a></h2><h3 id="Description-3"><a href="#Description-3" class="headerlink" title="Description"></a>Description</h3><p>Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.</p><h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><p>There are multiple solutions to this problem, the two most well-known ways are max-heap and partition using ideas of quicksort.</p><p>####heap</p><p>Use a max heap to store the elements, then we pop k times to get the kth largest one, and the time complexity is O(n + klogn), space complexity is O(n). A small optimization is to only store the k largest elements in a min-heap, so the top element is the answer and the time complexity is O(nlogk), space time complexity is O(k).</p><h4 id="partition"><a href="#partition" class="headerlink" title="partition"></a>partition</h4><p>The partition idea of quicksort is choosing a pivot and partition an array into two subarrays such that the left part is all less than the pivot and the right part is all larger than the pivot. So if the number of elements in left part is less than k, then the kth largest must be in the right part, otherwise it’s in the left part. So using partition function and a binary search, we can finally get the answer. The time complexity is T(n) = T(n/2) + O(n). The average time complexity is O(n) and the worst case is O(n^2). We can choose the pivot randomly to avoid the worst case and get a guaranteed time complexity of O(n).</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;The Divide And Conquer Problems in LeetCode.&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://hexiecs.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://hexiecs.com/tags/LeetCode/"/>
    
      <category term="Divide and conquer" scheme="http://hexiecs.com/tags/Divide-and-conquer/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-Tree</title>
    <link href="http://hexiecs.com/2019/12/24/LeetCode/LeetCode-Tree/"/>
    <id>http://hexiecs.com/2019/12/24/LeetCode/LeetCode-Tree/</id>
    <published>2019-12-24T00:45:19.000Z</published>
    <updated>2020-01-28T03:05:38.647Z</updated>
    
    <content type="html"><![CDATA[<p>The Tree Problems in LeetCode.</p><a id="more"></a><h2 id="Validate-Binary-Search-Tree"><a href="#Validate-Binary-Search-Tree" class="headerlink" title="Validate Binary Search Tree"></a><a href="https://leetcode.com/problems/validate-binary-search-tree/" target="_blank" rel="noopener">Validate Binary Search Tree</a></h2><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>Valid whether a tree is a BST.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>To validate a BST, a straightforward solution is to inorder traverse the tree, and form an array. Then just to check whether the array is in ascending order. However, a better solution that requires less time and memory is to determine the result when traverse the tree rather than need a extra array. Using the idea of the array, in fact, the apperance order of numbers in the array is the arriving orders of nodes when we in order traverse the tree, which  means, if a number is right before another number in the array, then its the previous nodes before the another nodes in inorder traversal. So we just need to save the previous node when we traverse, and to promise it is less than the current node to form an ascending order.</p><h2 id="Binary-Tree-Level-Order-Traversal"><a href="#Binary-Tree-Level-Order-Traversal" class="headerlink" title="Binary Tree Level Order Traversal"></a><a href="https://leetcode.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">Binary Tree Level Order Traversal</a></h2><h3 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h3><p>Given a binary tree, output the nodes by level order (nodes in one level output as a vector).</p><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><p>The idea is simple - do BFS by using a queue to store the children of the nodes. But determining when to terminate current level and move to the next level is a little tricky, we can get the total number of nodes in next level after we finish traversing current level. When we are traversing the next level, it is easy to determine when to terminate because we have known the total number of nodes in that level.</p><h2 id="Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal"><a href="#Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal" class="headerlink" title="Construct Binary Tree from Preorder and Inorder Traversal"></a><a href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" target="_blank" rel="noopener">Construct Binary Tree from Preorder and Inorder Traversal</a></h2><h3 id="Description-2"><a href="#Description-2" class="headerlink" title="Description"></a>Description</h3><p>Given preorder and inorder traversal of a tree, construct the binary tree.</p><h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><p>The preorder of a tree is visiting root node first and then left subtree and then right subtree, so if we have a preorder traversal, how can we determine the next node is on the left or on the right of current node? The inorder traversal is used to solve this. The inorder is visiting left subtree first and then root node and then right subtree. So if the positon of the next node in inorder traversal is less than the position of current node, it is on the left, otherwise it’s on the right. A tricky thing is that if it is on the left of the current node, it must be the immediate left children, since we visit root node and then visit immediate left children in preorder, which is easy to handle. However, if it is on the right, it may be the immediate right children or the children of ancestors of current node. How can we determine which node is the parent? To solve this, we should keep a stack when we are traversing preorder to save the ancestors. When we want to determine which ancestor is the real parent of the node, we can do a while loop to find the topest node which the child node is on the right. In detail, we can do a which loop which checks if the inorder position of the top of the stack(which is the ancestors from the bottom) is less than the inorder position onf the child node. If the answer is yes, we can pop the top node and continue the process since it may not be the topest node to match the condition. If the answer if no, we break the  loop and take the last poped top node as the answer.</p><h2 id="Flatten-Binary-Tree-to-Linked-List"><a href="#Flatten-Binary-Tree-to-Linked-List" class="headerlink" title="Flatten Binary Tree to Linked List"></a><a href="https://leetcode.com/problems/flatten-binary-tree-to-linked-list/" target="_blank" rel="noopener">Flatten Binary Tree to Linked List</a></h2><h3 id="Description-3"><a href="#Description-3" class="headerlink" title="Description"></a>Description</h3><p>Given a binary tree, flatten it to a linked list in-place.</p><h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><p>The flatten linked list of a tree means a linked list whose nodes are the preorder of the tree and the nodes are all pointed by the right child pointer of its parent nodes. To do this, we can make the right pointer of every node points at its left subtree and the last node visited in left subtree points to its right subtree, which forms a linked list. Also note that if a node doesn’t have a left subtree(which means we can’t make it points to right subtree), we should make its right pointer still points its right subtree.</p><h2 id="Binary-Tree-Maximum-Path-Sum"><a href="#Binary-Tree-Maximum-Path-Sum" class="headerlink" title="Binary Tree Maximum Path Sum"></a><a href="https://leetcode.com/problems/binary-tree-maximum-path-sum/" target="_blank" rel="noopener">Binary Tree Maximum Path Sum</a></h2><h3 id="Description-4"><a href="#Description-4" class="headerlink" title="Description"></a>Description</h3><p>Given a binary tree, find the maximum path sum of it. The path is defined as a sequence of nodes starting from any node to any node along the parent-child connection. It must contain at least one node.</p><h3 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h3><p>The maximum path must go through a root node of the tree or its subtree, so we need to do a recursive search to find the maximum path that going through the root node in every subtree . To find the maximum path sum of a tree that going through its root node, we find the maxmium sum of sequence nodes that start from root node to the left subtree and right subtree respectively, which is also done in the recursive function. If any of them is positive, we take it into the maximum sum path.</p><h2 id="Implement-Trie-Prefix-Tree"><a href="#Implement-Trie-Prefix-Tree" class="headerlink" title="Implement Trie (Prefix Tree)"></a><a href="https://leetcode.com/problems/implement-trie-prefix-tree/" target="_blank" rel="noopener">Implement Trie (Prefix Tree)</a></h2><h3 id="Description-5"><a href="#Description-5" class="headerlink" title="Description"></a>Description</h3><p>Implement a trie with insert, search, and startwith methods.</p><h3 id="Solution-5"><a href="#Solution-5" class="headerlink" title="Solution"></a>Solution</h3><p>Since there are only lowercase letters, a trie node will have 26 pointers to point to each letter respectively. For the insert method, we iterate the characters of the words by starting from the root pointer of the trie and see if current character has been inserted in the trie, which is indicated by if the pointer to the character is not NULL.  If it is NULL, a new trie node should be created in it. Then we traverse to the children node. Finally, we perform a word path. Note that since we need to know if there exist certain words (the search method), we should record if the character is the end of the word. </p><p>For the search method, we perform the same traverse path, if there are some characters of the word don’t exist in the trie then return false. If every character exists and the last character is the end of a word, we return true.</p><p>The startwith method is the same as the search method except that if needn’t check if a character is the end of the word.</p><p>##<a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/" target="_blank" rel="noopener">Lowest Common Ancestor of a Binary Tree</a></p><h3 id="Description-6"><a href="#Description-6" class="headerlink" title="Description"></a>Description</h3><p>Given a binary tree, find the lowest common ancestors of two given nodes in the tree.</p><h3 id="Solution-6"><a href="#Solution-6" class="headerlink" title="Solution"></a>Solution</h3><p>The two nodes are guaranteed existing in the tree. We can use a recursive solution. If the two nodes both exist in the left subtree, then the LCA of them is in the left subtree.Similarly, if they both exist in right subtree, the LCA of them is in the right subtree. Otherwise, one of them is located in the left subtree and the other is located in the right subtree, in this case the LCA is the root node. If the root node equals to either of the two given nodes, then the LCA is the root node. If the root node is NULL, then the LCA is NULL too of course. In the end of each recursion, we return the LCA(possibly NULL)  to the parent recursion.</p><h2 id="Serialize-and-Deserialize-Binary-Tree"><a href="#Serialize-and-Deserialize-Binary-Tree" class="headerlink" title="Serialize and Deserialize Binary Tree"></a><a href="https://leetcode.com/problems/serialize-and-deserialize-binary-tree/" target="_blank" rel="noopener">Serialize and Deserialize Binary Tree</a></h2><h3 id="Description-7"><a href="#Description-7" class="headerlink" title="Description"></a>Description</h3><p>Given a binary tree, design a serialization algorithm to serialize the binary tree to a string and a deserialization algorithm to construct the binary tree from the string.</p><h3 id="Solution-7"><a href="#Solution-7" class="headerlink" title="Solution"></a>Solution</h3><p>We can use preorder of the binary tree to serialization and deserialization. When we need to move to a next node, we add ‘,’ to the string to mark it. When we encounter a null node, we use a special character like ‘X’ to denote it. </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;The Tree Problems in LeetCode.&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://hexiecs.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://hexiecs.com/tags/LeetCode/"/>
    
      <category term="Tree" scheme="http://hexiecs.com/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-Array</title>
    <link href="http://hexiecs.com/2019/12/22/LeetCode/LeetCode-Array/"/>
    <id>http://hexiecs.com/2019/12/22/LeetCode/LeetCode-Array/</id>
    <published>2019-12-22T15:40:32.000Z</published>
    <updated>2020-02-11T14:41:49.176Z</updated>
    
    <content type="html"><![CDATA[<p>The Array Problems in LeetCode</p><a id="more"></a><h2 id="First-Missing-Positive"><a href="#First-Missing-Positive" class="headerlink" title="First Missing Positive"></a><a href="https://leetcode.com/problems/first-missing-positive/" target="_blank" rel="noopener">First Missing Positive</a></h2><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>Given an integer array and find the first missing positive number.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>Suppose the array has n elements, so there are two possibilities: </p><ol><li>1 - n are all in the array, so the missing integer is n+1</li><li>some integers are missed, to find it, if we put every integer in its exact position, which means, 1 is the first element, 2 is the second…, so there must be some positions where its value doesn’t match.</li></ol><p>So we put every integer in its ought position. After that, the first position that value is not pos + 1 is the answer. </p><h2 id="Longest-Consecutive-Sequence"><a href="#Longest-Consecutive-Sequence" class="headerlink" title="Longest Consecutive Sequence"></a><a href="https://leetcode.com/problems/longest-consecutive-sequence/" target="_blank" rel="noopener">Longest Consecutive Sequence</a></h2><h3 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h3><p>Given an unsorted array of integers, find the length of the longest consecutive elements sequence. E.g. the array is [100, 4, 200, 1, 3, 2], the longest consecutive elements sequence is 1, 2, 3, 4, So the length is 4.</p><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><p>The complexity needs to be O(n). We can use unordered_map to maintain the longest consecutive sequence of each element. To do that, we iterate over every element, if it has been visited, we skip it because it won’t contribute to this element’s result or any other element’s. If it has not been visited, let’s say the element is n. If n+1 or n-1 is visited, it will extend the result of n+1 or n-1 or both. If neither of them is visited, we just init the result of n as 1. Note that if both of n+1 and n-1 have been visited,  then the element n can link the two sequence into one whole sequence.</p><h2 id="Maximum-Product-Subarray"><a href="#Maximum-Product-Subarray" class="headerlink" title="Maximum Product Subarray"></a><a href="https://leetcode.com/problems/maximum-product-subarray/" target="_blank" rel="noopener">Maximum Product Subarray</a></h2><h3 id="Description-2"><a href="#Description-2" class="headerlink" title="Description"></a>Description</h3><p>Given an integer array, find the contiguous subarray which has the largest product.</p><h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><p>We can iterate the array from left to right and find the largest product of  subarray which ends with current element. Let’s say current element is A[i] and A[i] &gt;= 0, and the largest product of subarray which ends with A[i-1] is p[i-1], so p[i] = max(A[i], p[i-1]*A[i]). When A[i] &lt; 0, to get p[i], we need to know the minimum product of subarray which ends with A[i-1], let’s call it m[i-1]. So p[i] = max(A[i], m[i-1] * A[i]). Obviously, we don’t need extra O(n) space to store p[i] or m[i] during the iteration, instead a single p[i] and m[i] to represent current subarray’s largest product is enough.</p><h2 id="Product-of-Array-Except-Self"><a href="#Product-of-Array-Except-Self" class="headerlink" title="Product of Array Except Self"></a><a href="https://leetcode.com/problems/product-of-array-except-self/" target="_blank" rel="noopener">Product of Array Except Self</a></h2><h3 id="Description-3"><a href="#Description-3" class="headerlink" title="Description"></a>Description</h3><p>Given an array <code>nums</code> of n integers where n &gt; 1, return an array <code>output</code> where <code>output[i]</code> is equal to the product of all elements of <code>nums</code> except <code>nums[i]</code>. Note that division is forbidden and constant space and linear time is needed.</p><h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><p>A straight forward solution is to use two arrays <code>left</code> and <code>right</code> where left[i] represents the product of all elements from 0 to i - 1 whereas right[i] represents the product of all elements from i + 1 to n-1, so the output[i] = left[i] * right[i]. But this makes a linear space solution, which needs to be optimized. We can use output array to replace left and right array. To do that, we first store results of left in output array in a left to right order iteration, and then we can use a single integer variable to represent current right[i] when we iterate from right to left. So output[i] = output[i] * right.</p><h2 id="Queue-Reconstruction-by-Height"><a href="#Queue-Reconstruction-by-Height" class="headerlink" title="Queue Reconstruction by Height"></a><a href="https://leetcode.com/problems/queue-reconstruction-by-height/" target="_blank" rel="noopener">Queue Reconstruction by Height</a></h2><h3 id="Description-4"><a href="#Description-4" class="headerlink" title="Description"></a>Description</h3><p>Given an array of pairs (h, k), which means there are k numbers that are greater or equal than current number h but they are in random order in the input array, so please reconstruct original order array.</p><h3 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h3><p>Let’s say the output array is result. Firstly, we pick up the maximum numbers, for the maximum numbers there are no other numbers greater than them, so they are placed at what their k index are. Then we pick up the second maximum numbers, wherever they are placed at won’t influence the maximum numbers’ k values, so we only need to consider themselves. We can find that the second maximum numbers are also placed at their k indexes  of current result array. We’ll continue the process and insert the numbers at their k indexes positions. As for the implementation, we can sort the array first so we can iterate the number from the most maximum.</p><h2 id="Subarray-Sum-Equals-K"><a href="#Subarray-Sum-Equals-K" class="headerlink" title="Subarray Sum Equals K"></a><a href="https://leetcode.com/problems/subarray-sum-equals-k/" target="_blank" rel="noopener">Subarray Sum Equals K</a></h2><h3 id="Description-5"><a href="#Description-5" class="headerlink" title="Description"></a>Description</h3><p>Given an array of integers and a integer k, you need to find the total number of continuous subarrays whose sum equals to k.</p><h3 id="Solution-5"><a href="#Solution-5" class="headerlink" title="Solution"></a>Solution</h3><p>We can calculate any continuous subarray’s sum by prefix sum method. For any subarray has the endpoint indices as <code>(left, right)</code> and sum equals to k, the prefix sum must match: <code>sum[right] - sum[left] = k</code>. So the problem can be converted to calculated the number of  indices on the right side matches <code>sum[indices] = sum[left] + k</code> for any indices <code>left</code>.  We can iterate the prefix sum array from right to left and use a hashmap to record the frequency of every sum. While iterating, the final answer will plus map[sum + k] for every current iterating sum.</p><h2 id="Task-Scheduler"><a href="#Task-Scheduler" class="headerlink" title="Task Scheduler"></a><a href="https://leetcode.com/problems/task-scheduler/" target="_blank" rel="noopener">Task Scheduler</a></h2><h3 id="Description-6"><a href="#Description-6" class="headerlink" title="Description"></a>Description</h3><p>Given a char array representing tasks cpu needs to do. It contains capital letters where different letters represent different tasks. Tasks could be done without original orders. Each task should be done in one interval. For one interval, cpu could do one task or just be idle.</p><p>However, there is a non-negative integer n that means between two same tasks, there must be at least n intervals that cpu are doing different tasks or be idle.</p><p>You need to find minimum intervals that cpu will take to finish all the tasks.</p><h3 id="Solution-6"><a href="#Solution-6" class="headerlink" title="Solution"></a>Solution</h3><p>We can use a greedy algorithm to solve this. The most frequent tasks will determine the number of idle intervals we must have, so we pick the most frequent tasks first. Say the frequency is max and there are max_count tasks that have the largest frequency,  this will form (max - 1) * (n - max_count + 1) idle intervals. We can imagine there are slots that tasks can be scheduled in. Assume there is only one most frequent task, there will be (max - 1) * (n) idle slots intervals after it is scheduled. Then we can put other tasks in these idle slots. What if there are multiple most frequent tasks? Following most frequent tasks can be put right after the first one, so the number of idle slots become (max - 1) (n - max_count + 1). What if the remaining idle slots are less than the remaining tasks? The answer will be the number of tasks in this case because we can fill the idle intervals with tasks and put remaining tasks in the end.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;The Array Problems in LeetCode&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://hexiecs.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://hexiecs.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-Two Pointers</title>
    <link href="http://hexiecs.com/2019/12/21/LeetCode/LeetCode-Linked-List/"/>
    <id>http://hexiecs.com/2019/12/21/LeetCode/LeetCode-Linked-List/</id>
    <published>2019-12-21T13:40:28.000Z</published>
    <updated>2020-01-15T00:36:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>The Two Pointers problems in LeetCode</p><a id="more"></a><h2 id="Linked-List-Cycle"><a href="#Linked-List-Cycle" class="headerlink" title="Linked List Cycle"></a><a href="https://leetcode.com/problems/linked-list-cycle/" target="_blank" rel="noopener">Linked List Cycle</a></h2><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>Check whether a linked list has a cycle</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>Use two pointers, one go forward one step at a time and the other go forward two steps at a time, if there is a cycle, the two pointers will meet, otherwise they won’t meet.</p><h2 id="Linked-List-Cycle-II"><a href="#Linked-List-Cycle-II" class="headerlink" title="Linked List Cycle II"></a><a href="https://leetcode.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">Linked List Cycle II</a></h2><h3 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h3><p>Find the start node of the cycle of a linked list</p><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><p>Also use two pointers as the previous problem, but need some math observation.  Let the distance that the slow pointer has walked when the two pointers meet  is <code>k</code>, so the distance of the fast pointer is <code>2k</code>. And the substraction of this two distances  <code>2k - k = k</code>is exactly the length of the cycle. Let the distance between the start node of the list and the start node of the cycle is <code>s</code>, and the distance between the start node of the cycle and the first meeting node of the pointers is <code>m</code>,  then <code>s + m = k</code>, so <code>s = k - m</code> where the <code>k</code> is the length of the circle. To find the  start node of the cycle, we let a pointer start from the first meeting node, and another pointer start from the start node of the list, and both of them go forward one step at a time. When they meet, the first pointer goes exactly k - m steps which is the answer, so the second pointer is the start node of the cycle.</p><h2 id="Find-the-Duplicate-Number"><a href="#Find-the-Duplicate-Number" class="headerlink" title="Find the Duplicate Number"></a><a href="https://leetcode.com/problems/find-the-duplicate-number/" target="_blank" rel="noopener">Find the Duplicate Number</a></h2><h3 id="Description-2"><a href="#Description-2" class="headerlink" title="Description"></a>Description</h3><p>Give an integer array which has n + 1 numbers and numbers range from 1 to n. Assume there is only a duplicate number and find it.</p><h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><p>This is the integer version of the previous problem, and the solution is the same. If we treat the integer array as a linked list which means using the value of integer as the next jumping position. Suppose we have an array [2, 1, 3], then the index-&gt;value map is : 0-&gt;2, 1-&gt;1, 2-&gt;3. And the linked list is 0-&gt;2-&gt;3, and 3 is beyond the array index limit. If there is a duplicate number in the array, then the linked list must has a cycle, and the duplicate number is the start node of the cycle. </p><h2 id="Copy-List-with-Random-Pointer"><a href="#Copy-List-with-Random-Pointer" class="headerlink" title="Copy List with Random Pointer"></a><a href="https://leetcode.com/problems/copy-list-with-random-pointer/" target="_blank" rel="noopener">Copy List with Random Pointer</a></h2><h3 id="Description-3"><a href="#Description-3" class="headerlink" title="Description"></a>Description</h3><p>Given a linked list that each node has an additional random pointer which could point to any node in the list or null. Do a deep copy of the linked list.</p><h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><p>An intuitive solution would be using a hash map to store the relationship between original node and copy node which has a time complexity of O(1) and space complexity of O(n). We can optimize the space complexity to O(1) by not using map to store the relationship, instead we directly put each copy node to the next of its original node. So when we want to find the random pointer node of a copy node, we just take the node after the random node of its original node. In detail, the algorithm runs three rounds:</p><ol><li>iterate the linked list and put each copy node to the next of original node.</li><li>we assign the random pointer of copy node by using the next node of the random node of original node.</li><li>extract the copy node from the linked list. </li></ol><h2 id="Sort-List"><a href="#Sort-List" class="headerlink" title="Sort List"></a><a href="https://leetcode.com/problems/sort-list/" target="_blank" rel="noopener">Sort List</a></h2><h3 id="Description-4"><a href="#Description-4" class="headerlink" title="Description"></a>Description</h3><p>Sort a linked list in O(nlog(n)) time complexity and constant space complexity.</p><h3 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h3><h4 id="Recursive-way"><a href="#Recursive-way" class="headerlink" title="Recursive way"></a>Recursive way</h4><p>In fact, the space complexity of recursive solution is not constant. it’s O(log(n)).</p><p>Basic idea is merge sort, but there are two questiones needed to be figured out:</p><ul><li><p>How to split a linked list into two in a merge sort process?</p><p>Well, we can iterate the linked list first to get the length of it. Then iterate from the head again to get the middle node of the list. So the two part are the head and the middle node. The complexity of this is O(n).</p></li><li><p>Since we can’t swap two nodes of linked list as the array, how can we merge two linked list in place and finally place the merged linked list in the original linked list?</p><p>To merge two linked lists in place, we need a head pointer to record the head of the two linked list. The basic logic is:</p><ol><li><p>if head == NULL, head = n1 or n2 (depends on the order)</p></li><li><p>if n1 &lt; n2, head-&gt;next = n1; otherwise head-&gt;next = n2; </p></li><li><p>loop until n1== NULL or n2 =NULL or n1 reach list1 length or n2 reach list2 length. Here two linked list are not guaranteed end with NULL because we may merge two linked list of the middle of original linked list, so we need to pass length of each list into the merge function, which can be gotten from the split process.</p></li><li><p>This is a recursive process, every time we merge two linked lists and return the result list.</p></li></ol></li></ul><h4 id="Iterative-way"><a href="#Iterative-way" class="headerlink" title="Iterative way"></a>Iterative way</h4><p>Since the recursive way is not constant space complexity, we need to use a iterative way.</p><p>Firstly, how to merge two arrays using iterative way? We can merge length 1 subarray first, and then merge length 2 subarrays, and then merge length 4  subarrays… until the whole array is merged. This process can be easily implemented by a for loop, and the loop variant is the length of subarray we currently merge. </p><p>So the problem is to apply this solution to linked list. Similarly, we use a for loop to merge different length of sub linked list from length 1 to length n. We first split the linked list into two sub linked lists of current length, then merge them and go to next two sub linked list. But when we merge two sub linked lists, we need to pass the previous node of the two sub linked lists to the merge function because we need to save the merged list to originial list. To ensure every node has a previous node, we need to create a dummy node before the head of the list.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;The Two Pointers problems in LeetCode&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://hexiecs.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://hexiecs.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Linux/Linux shell脚本编程学习</title>
    <link href="http://hexiecs.com/2019/10/19/Linux/Linux-shell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    <id>http://hexiecs.com/2019/10/19/Linux/Linux-shell脚本编程学习/</id>
    <published>2019-10-19T15:07:22.000Z</published>
    <updated>2019-11-24T07:33:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>Linux shell编程学习，持续更新…</p><a id="more"></a><h2 id="循环处理带有空格的文件名列表"><a href="#循环处理带有空格的文件名列表" class="headerlink" title="循环处理带有空格的文件名列表"></a>循环处理带有空格的文件名列表</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># file_list中的文件名含有空格</span><br><span class="line">file_list=`find . -type f -name &quot;*&quot;`</span><br><span class="line">echo &quot;$file_list&quot; | while read line</span><br><span class="line">do</span><br><span class="line"># $line即为文件名，拿来处理即可</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>注意两点:</p><ol><li>echo后的双引号是必须的，如果不带双引号的话，file_list中的换行符会被忽略，所有的文件名都会在同一行.</li><li>不能用for循环简单的处理，因为for循环没法简单的处理带有空格的文件名</li></ol><h2 id="将命令列表放入后台执行"><a href="#将命令列表放入后台执行" class="headerlink" title="将命令列表放入后台执行"></a>将命令列表放入后台执行</h2><p><code>(tar -cf Rich.tar /home/rich ; tar -cf My.tar /home/christine)&amp;</code><br>这样就创建了一个子shell用于执行这个命令列表，命令用（）包起来会被子shell执行。</p><h2 id="处理多个数学算术表达式"><a href="#处理多个数学算术表达式" class="headerlink" title="处理多个数学算术表达式"></a>处理多个数学算术表达式</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> cat test12 </span><br><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line">var1=10.46 </span><br><span class="line">var2=43.67 </span><br><span class="line">var3=33.2 </span><br><span class="line">var4=71</span><br><span class="line">var5=$(bc &lt;&lt; EOF </span><br><span class="line">scale = 4</span><br><span class="line">a1 = ( $var1 * $var2) </span><br><span class="line">b1 = ($var3 * $var4) </span><br><span class="line">a1 + b1</span><br><span class="line">EOF</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="算术表达式"><a href="#算术表达式" class="headerlink" title="算术表达式"></a>算术表达式</h2><h3 id="expr语句，比较麻烦"><a href="#expr语句，比较麻烦" class="headerlink" title="expr语句，比较麻烦"></a>expr语句，比较麻烦</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">expr 1 + 2</span><br><span class="line">expr $var1 \* $var2</span><br><span class="line">var = $(expr $var1 \* $var2)</span><br></pre></td></tr></table></figure><h3 id><a href="#" class="headerlink" title="$[]"></a>$[]</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span>[1 + 2]</span><br><span class="line"><span class="meta">$</span>[$var1 * $var2]</span><br></pre></td></tr></table></figure><h3 id="bc-可支持浮点运算"><a href="#bc-可支持浮点运算" class="headerlink" title="bc 可支持浮点运算"></a>bc 可支持浮点运算</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> bc -q </span><br><span class="line">3.44 / 5 0 </span><br><span class="line">scale=4 </span><br><span class="line">3.44 / 5 </span><br><span class="line">.6880 </span><br><span class="line">quit</span><br><span class="line"><span class="meta">$</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> bc -q </span><br><span class="line">var1=10 </span><br><span class="line">var1 * 4 </span><br><span class="line">40</span><br><span class="line">var2 = var1 / 5 </span><br><span class="line">print var2</span><br><span class="line">2</span><br><span class="line">quit</span><br><span class="line"><span class="meta">$</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> cat test9</span><br><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line">var1=$(echo "scale=4; 3.44 / 5" | bc) </span><br><span class="line">echo The answer is $var1</span><br><span class="line"><span class="meta">$</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ cat test12 </span><br><span class="line">#!/bin/bash</span><br><span class="line">var1=10.46 </span><br><span class="line">var2=43.67 </span><br><span class="line">var3=33.2 </span><br><span class="line">var4=71</span><br><span class="line">var5=$(bc &lt;&lt; EOF scale = 4</span><br><span class="line">a1 = ( $var1 * $var2) b1 = ($var3 * $var4) a1 + b1</span><br><span class="line">EOF</span><br><span class="line">)</span><br><span class="line">echo The final answer for this mess is $var5</span><br></pre></td></tr></table></figure><h2 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if cmd</span><br><span class="line">then</span><br><span class="line">else</span><br></pre></td></tr></table></figure><p>如果cmd的返回值是0，则then后面的会执行，否则执行else</p><p>if test condition = if [ condition ]    </p><h3 id="数字比较"><a href="#数字比较" class="headerlink" title="数字比较"></a>数字比较</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">n1 -eq n2 </span><br><span class="line"></span><br><span class="line">n1 -ge n2 </span><br><span class="line"></span><br><span class="line">n1 -gt n2 </span><br><span class="line"></span><br><span class="line">n1 -le n2 </span><br><span class="line"></span><br><span class="line">n1 -lt n2 </span><br><span class="line"></span><br><span class="line">n1 -ne n2</span><br></pre></td></tr></table></figure><h3 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">str1 = str2 </span><br><span class="line">str1 != str2 </span><br><span class="line">str1 &lt; str2 </span><br><span class="line">str1 &gt; str2 </span><br><span class="line">-n str1</span><br><span class="line">-z str1</span><br></pre></td></tr></table></figure><h3 id="文件比较"><a href="#文件比较" class="headerlink" title="文件比较"></a>文件比较</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-d file</span><br><span class="line"> -e file</span><br><span class="line"> -f file</span><br><span class="line"> -r file</span><br><span class="line"> -s file  # not empty</span><br><span class="line"> -w file</span><br><span class="line"> -x file</span><br><span class="line"> -O file # owned by current user</span><br><span class="line"> -G file # default group is the same as the current user</span><br><span class="line"> file1 -nt file2   #newer than</span><br><span class="line"> file1 -ot file2   #older than</span><br></pre></td></tr></table></figure><h3 id="布尔逻辑"><a href="#布尔逻辑" class="headerlink" title="布尔逻辑"></a>布尔逻辑</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[condition1] || [condition2]</span><br><span class="line">[condition1] &amp;&amp; [condition2]</span><br></pre></td></tr></table></figure><h3 id="双圆括号"><a href="#双圆括号" class="headerlink" title="双圆括号"></a>双圆括号</h3><p>(())</p><p>双括号中可以有高级的算术表达式</p><h3 id="双方括号"><a href="#双方括号" class="headerlink" title="双方括号"></a>双方括号</h3><p>[[]]</p><p>里面可以有高级的字符串比较，比如正则表达式</p><h2 id="case表达式"><a href="#case表达式" class="headerlink" title="case表达式"></a>case表达式</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">case $var in </span><br><span class="line">value1)</span><br><span class="line">  xxx</span><br><span class="line">value2 | value3)</span><br><span class="line">  yyy</span><br><span class="line">*)</span><br><span class="line">  zzz</span><br><span class="line">esac</span><br></pre></td></tr></table></figure><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><h3 id="第一种方式"><a href="#第一种方式" class="headerlink" title="第一种方式"></a>第一种方式</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for iter in value1 value2 value3</span><br><span class="line">do</span><br><span class="line">   xxx</span><br><span class="line">done</span><br><span class="line">echo $iter # 在循环结束后，iter的值为list的最后一个值</span><br></pre></td></tr></table></figure><p>当value1，value2…中含有空格或’时，用双引号把value括起来</p><p>list可以来自于命令的输出。比如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> cat test5</span><br><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"><span class="meta">#</span> reading values from a file</span><br><span class="line">file="states"</span><br><span class="line">for state in $(cat $file) do</span><br><span class="line">echo "Visit beautiful $state" </span><br><span class="line">done</span><br><span class="line"><span class="meta">$</span> cat states </span><br><span class="line">Alabama </span><br><span class="line">Alaska </span><br><span class="line">Arizona </span><br><span class="line">Arkansas </span><br><span class="line">Colorado </span><br><span class="line">Connecticut </span><br><span class="line">Delaware </span><br><span class="line">Florida </span><br><span class="line">Georgia</span><br><span class="line"><span class="meta">$</span> ./test5</span><br><span class="line">Visit beautiful Alabama </span><br><span class="line">Visit beautiful Alaska </span><br><span class="line">Visit beautiful Arizona </span><br><span class="line">Visit beautiful Arkansas </span><br><span class="line">Visit beautiful Colorado </span><br><span class="line">Visit beautiful Connecticut </span><br><span class="line">Visit beautiful Delaware </span><br><span class="line">Visit beautiful Florida </span><br><span class="line">Visit beautiful Georgia</span><br><span class="line"><span class="meta">$</span></span><br></pre></td></tr></table></figure><p>默认情况下bash shell会把空格、tab、换行符视为数据的分隔符，这是由系统的环境变量IFS决定的，当不符合我们的需求时，可以临时改一下IFS，比如如果我们只想要换行符作为数据的分隔符，不想要空格和tab。那我们可以这样做：</p><p><code>IFS=$&#39;\n&#39;</code></p><p>当然也可以把IFS设为其它的值，比如冒号之类的，这在遍历/etc/passwd文件时很有用。</p><h3 id="C风格for循环"><a href="#C风格for循环" class="headerlink" title="C风格for循环"></a>C风格for循环</h3><p><code>for (( variable assignment ; condition ; iteration process ))</code></p><p><code>for (( i=1; i &lt;= 10; i++ ))</code></p><h2 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while test command # the same as 'while [command]'</span><br><span class="line">do</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h2 id="until循环"><a href="#until循环" class="headerlink" title="until循环"></a>until循环</h2><p>和while循环的意思相反，当test command的返回值非0时，循环体才执行</p><h2 id="break，continue"><a href="#break，continue" class="headerlink" title="break，continue"></a>break，continue</h2><ol><li><p>break，continue默认作用于当前循环</p></li><li><p>break n ，continue n作用于第n层循环 当前循环的level为1，往外一层就+1</p></li></ol><h2 id="重定向for循环的输出"><a href="#重定向for循环的输出" class="headerlink" title="重定向for循环的输出"></a>重定向for循环的输出</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for iter in list</span><br><span class="line">do</span><br><span class="line">done &gt; text.txt</span><br><span class="line"></span><br><span class="line">for iter in lis t</span><br><span class="line">do</span><br><span class="line">done | sort</span><br></pre></td></tr></table></figure><h2 id="获取脚本名字"><a href="#获取脚本名字" class="headerlink" title="获取脚本名字"></a>获取脚本名字</h2><p><code>$0</code>: 脚本名字，带运行时的路径</p><p><code>basename $0</code> : 脚本名字，忽略路径</p><h2 id="特殊的脚本变量"><a href="#特殊的脚本变量" class="headerlink" title="特殊的脚本变量"></a>特殊的脚本变量</h2><p>$#: 命令行参数的个数</p><p>$*: 把所有的命令行参数作为一个完整的字符串</p><p>$@: 把每个命令行参数作为独立的字符串</p><h2 id="shift命令"><a href="#shift命令" class="headerlink" title="shift命令"></a>shift命令</h2><p>把所有的命令行参数向左移一位，比如<code>$2</code>变成<code>$1</code>, <code>$1</code>被去掉了。shift命令还可以带参数，表示左移几位。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Linux shell编程学习，持续更新…&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://hexiecs.com/categories/Linux/"/>
    
    
      <category term="Linux命令行" scheme="http://hexiecs.com/tags/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C/"/>
    
  </entry>
  
  <entry>
    <title>英语写作词汇总结</title>
    <link href="http://hexiecs.com/2019/10/19/English/%E5%86%99%E4%BD%9C%E8%AF%8D%E6%B1%87%E6%80%BB%E7%BB%93/"/>
    <id>http://hexiecs.com/2019/10/19/English/写作词汇总结/</id>
    <published>2019-10-19T14:55:52.000Z</published>
    <updated>2019-12-03T00:11:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>英语写作中的vacabulary总结。持续更新…</p><a id="more"></a><h1 id="英语写作词汇总结"><a href="#英语写作词汇总结" class="headerlink" title="英语写作词汇总结"></a>英语写作词汇总结</h1><h2 id="连接词"><a href="#连接词" class="headerlink" title="连接词"></a>连接词</h2><h3 id="观点"><a href="#观点" class="headerlink" title="观点"></a>观点</h3><ol><li>I think/feel/believe that</li><li>Personally I feel that</li><li>As far as I am concerned</li><li>From my point of view</li><li>In my opinion</li><li>I think</li><li>In my view</li><li>I believe</li><li>I admit</li></ol><h3 id="同意-反对"><a href="#同意-反对" class="headerlink" title="同意/反对"></a>同意/反对</h3><ol><li>I agree</li><li>I concur</li><li>I disagree</li><li>I cannot agree</li><li>I oppose the idea</li><li>I cannot accept</li><li>I totally agree with the given idea that…..</li><li>I agree with the opinion that…..</li><li>I accept the fact that…..</li><li>I approve the idea…..</li></ol><h3 id="部分同意"><a href="#部分同意" class="headerlink" title="部分同意"></a>部分同意</h3><ol><li>To some extent…..</li><li>In a way…..</li><li>I agree with the given statement to some extent…..</li><li>Up to a point, I agree…..</li><li>More or less…..</li><li>So to speak…..</li></ol><p>Examples:<br>1) In a way, I agree that it is government’s responsibility to keep the environment clean, but without individual effort, it cannot be achieved.</p><p>2) To some extent, I agree with the opinion that space research is a waste of money but the invaluable effects these research can have could not be denied. </p><p>3) So to speak, mothers play the most important role in upbringing the children, however, the contribution a father can have to the children can’t be ignored.</p><h3 id="额外信息"><a href="#额外信息" class="headerlink" title="额外信息"></a>额外信息</h3><ol><li>Moreover</li><li>Furthermore</li><li>In addition</li><li>Additionally</li><li>Likewise</li><li>On top of that</li><li>Not only… but als</li><li>Also</li><li>As well as</li><li>Besides…</li><li>What is more…</li><li>Another point worth noting is…</li><li>Another factor to consider is…</li></ol><p>Examples:</p><p>1) On top of that, rich countries emit more CO2 than the rest of the world does and this is why they have greater responsibilities.</p><p>2) Another point worth noting is the number of TV channels we have these days.</p><p>3) What is more, leaders are born not made.</p><h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><ol><li>If</li><li>Unless</li><li>On the condition that</li><li>Provided that</li><li>As long as</li><li>Supposing that</li><li>Otherwise</li><li>In case</li><li>Whether</li><li>For this reason</li><li></li></ol><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><ol><li>For example</li><li>For instance</li><li>Such as</li><li>A very good example is </li><li>The best example is</li><li>To cite an example</li><li>To illustrate</li><li>One clear example</li><li>In other words</li><li>To give an example</li><li>This is particularly serious in the case of</li><li>the obvious example such as </li><li>there are surely some instances when</li><li>As an example…</li><li>Particularly</li><li>With respect to</li><li>To paraphrase</li><li></li></ol><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><ol><li>As a result</li><li>As a consequence</li><li>Consequently</li><li>Accordingly</li><li>Therefore</li><li>For that reason</li><li>Hence</li><li>As an effect</li><li>Thus</li><li>So</li><li>For this/that reason</li><li>Thereby…</li><li>… has led to/ … has resulted in</li><li>In this case</li></ol><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><ol><li>Since</li><li>Because</li><li>As</li><li>Due to</li><li>Owing to</li><li>Many people believe that this represents a problem because</li><li>One danger this presents is that</li><li>The reason why</li><li>On account of</li><li>One reason behind this is…</li></ol><h3 id="时间顺序"><a href="#时间顺序" class="headerlink" title="时间顺序"></a>时间顺序</h3><ol><li>Subsequently</li><li>Eventually</li><li>Meanwhile</li><li>Henceforth</li><li>At the same time…..</li><li>Since…..</li><li>After this / that…..</li><li>Before…..</li><li>After…..    </li><li>Afterwards …..</li><li>During…..    </li><li>While…..</li><li>Simultaneously…..    </li><li>Following this…..</li></ol><h3 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h3><ol><li>Especially</li><li>Clearly</li><li>Obviously</li><li>Specifically</li><li>Of course</li><li>In particular</li><li>It goes without saying that…</li><li>There is little doubt that…</li><li>After all</li><li>Certainly…..</li><li>Definitely…..</li><li>No doubt…..</li><li>Doubtlessly…..</li><li>Without any doubt…..</li><li>Undoubtedly…..</li></ol><p>Examples:<br>1) Of course, learning from books in a formal educational institution and learning from books for someone’s own interest are both highly important.</p><p>2) Definitely, practical lessons help us to have more deeply understanding, while theory learned from books will be forgotten far easier.</p><p>3) Undoubtedly ultimate exhaust of natural resources would create a chaos and many wild lives would be endangered as well.</p><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><ol><li>Despite</li><li>In spite of</li><li>By contrast</li><li>Alternatively</li><li>Another opinion could be</li><li>On the other hand</li><li>Still</li><li>On the contrary…</li><li>However…</li><li>Nevertheless…/ Nonetheless…</li><li>Oppositely…</li><li>Alternatively…</li><li>Unlike…</li><li>While…</li><li>Although…</li><li>Though…</li><li>Even though…</li><li>Despite… / In spite of…</li><li>In spite of the fact that…</li><li>In contrast to this…</li><li>Then again…</li><li>Even so…</li><li>Yet…</li><li>Meanwhile..</li></ol><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><ol><li>In comparison</li><li>Admittedly</li><li>Similarly</li><li>Likewise</li><li>In the same way</li><li>Like the previous point…</li><li>Similar to…</li><li>Also…</li><li>At the same time…</li><li>Just as…</li></ol><p>Examples:<br>1) Similarly, all the companies and offices are becoming automated and using computers, the internet and other technologies vastly than any other time in history……. </p><p>2) At the same time software could be used for many purposes such as learning through computers, accounting in computers, drawing, storage of information, sending information from one person to other persons etc.</p><p>3) Also reading books is like peeking into the minds of the greatest people - A book is like a conversation with the writer and reading many books gives us an insight into the thinking process of different writers.</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>To sum up</li><li>In conclusion</li><li>To conclude</li><li>To draw the conclusion</li><li>In short…</li><li>In a word…</li><li>To put it simply…</li><li>That is to say…</li><li>To repeat in short….</li><li>To summarise…</li></ol><h3 id="转折"><a href="#转折" class="headerlink" title="转折"></a>转折</h3><ol><li>in addition to these, however</li></ol><h3 id="引出句子"><a href="#引出句子" class="headerlink" title="引出句子"></a>引出句子</h3><ol><li>it is safe to say that</li><li>There is little doubt that</li></ol><h3 id="表达观点"><a href="#表达观点" class="headerlink" title="表达观点"></a>表达观点</h3><ol><li>Research shows that…</li><li>Research has found that…</li><li>When it comes to…</li><li>With respect to…</li><li>Not only… but also…</li><li>In terms of…</li></ol><p>Examples:</p><p>1) Research shows that employment opportunity and crime ratio in a city has a deep underlying relationship and that is why…</p><p>2) When it comes to deciding who should be responsible to teach children the discipline…</p><p>3) With respect to mix-school classrooms, it is quite evident that…</p><h2 id="同义词"><a href="#同义词" class="headerlink" title="同义词"></a>同义词</h2><table><thead><tr><th>word1</th><th>word2</th><th>含义</th></tr></thead><tbody><tr><td>exceptional</td><td>keen</td><td>杰出的、厉害的</td></tr><tr><td>courtership</td><td>mate</td><td>求婚、求偶</td></tr><tr><td>chronic</td><td>long-term</td><td>长期的、慢性的</td></tr><tr><td>demographic</td><td>population</td><td>人口</td></tr></tbody></table><h2 id="各个段落的句子"><a href="#各个段落的句子" class="headerlink" title="各个段落的句子"></a>各个段落的句子</h2><h3 id="Useful-vocabulary-phrases-to-open-start-the-essay"><a href="#Useful-vocabulary-phrases-to-open-start-the-essay" class="headerlink" title="Useful vocabulary/phrases to open/start the essay:"></a>Useful vocabulary/phrases to open/start the essay:</h3><ol><li>Many/some people claim/opine/believe that…</li><li>There is no denying that…</li><li>It is often said that…</li><li>These days…/ Nowadays…/ In this day and age…</li><li>It goes without saying that…</li><li>It is universally accepted that…</li><li>We live in an age when many of us are…</li><li>People are divided in their opinion regarding…</li><li>…. is one of the most important issues…</li><li>Whether …. or …. is a controversial issue…</li><li>The issue of … has become extremely grown in importance in most countries over the few decades. It is considered that… While I accept…, I believe that. (partial agree and partial disagree)</li><li>In our modern world, the question whether… has been widely discussed. A fair portion of people believes that…, while others hold the opposite point of the view. As for me, I agree with the latter one.</li><li>Thesedays it is quite common for…</li></ol><h3 id="Useful-vocabulary-phrases-to-end-the-Introduction-part"><a href="#Useful-vocabulary-phrases-to-end-the-Introduction-part" class="headerlink" title="Useful vocabulary/phrases to end the Introduction part:"></a>Useful vocabulary/phrases to end the Introduction part:</h3><ol><li>Let us examine both views before reaching a concrete decision.</li><li>The following paragraphs discuss whether …… or …… and reach a reasonable conclusion.</li><li>The following essay takes a look at both sides of the argument.</li><li>My two cents go for…</li><li>However, I strongly believe that…</li><li>I oppose the view and my reasons will be explained in the following paragraphs.</li><li>I will support this view with arguments in the following paragraphs.</li><li>I personally believe that…</li><li>Thus the advantages far outweigh the disadvantages…</li><li>I wholeheartedly believe that this trend should be changed.</li><li>Although all of these have clear benefits for …,  the drawbacks also cannot be overlooked.</li></ol><h3 id="Vocabulary-for-the-opinion-part"><a href="#Vocabulary-for-the-opinion-part" class="headerlink" title="Vocabulary for the opinion part:"></a>Vocabulary for the opinion part:</h3><ol><li>In my opinion…</li><li>I strongly opine that…</li><li>I strongly agree with the idea that…</li><li>I strongly disagree with the given topic…</li><li>I think…</li><li>My opinion is that…</li><li>Personally speaking…</li><li>In my view…</li><li>I believe…</li><li>Apparently…</li><li>Personally speaking…</li><li>According to me…</li><li>From my point of view… (Not ‘In my point of view’)</li><li>As far as I am concerned…</li><li>From my perspective…</li><li>I realise…</li><li>To my way of thinking…</li><li>It seems to me that…</li><li>To me…</li><li>To my mind…</li><li>My own view on the matter is…</li><li>It appears that…</li><li>I feel that…</li><li>I understand…</li><li>I suppose…</li></ol><h3 id="Vocabulary-for-the-2nd-paragraph-Part"><a href="#Vocabulary-for-the-2nd-paragraph-Part" class="headerlink" title="Vocabulary for the 2nd paragraph Part:"></a>Vocabulary for the 2nd paragraph Part:</h3><ol><li>It is true that…</li><li>First…</li><li>First of all…</li><li>Firstly…</li><li>First and foremost…</li><li>Initially…</li><li>To begin with…</li><li>To start with…</li><li>Let us take a look at…</li><li>It is worth considering…</li><li>In the first place…</li><li>Though it is true that…</li><li>Some people believe that…</li><li>Many people think that…</li><li>According to many…</li><li>Some people believe that…</li><li>Many support the view that…</li><li>On the one hand…</li></ol><h3 id="Vocabulary-for-the-3rd-4th-……-paragraph-Part"><a href="#Vocabulary-for-the-3rd-4th-……-paragraph-Part" class="headerlink" title="Vocabulary for the 3rd, 4th …… paragraph Part:"></a>Vocabulary for the 3rd, 4th …… paragraph Part:</h3><ol><li>Second(ly)…  (Not ‘Second of all’)</li><li>Third(ly)…</li><li>Then…</li><li>Next…</li><li>After that…</li><li>And…</li><li>Again…</li><li>Also…</li><li>Besides…</li><li>Likewise…</li><li>In addition…</li><li>Consequently…</li><li>What’s more…</li><li>Furthermore…</li><li>Moreover…</li><li>Other people think that…</li><li>Other people believe that…</li><li>On the other hand…</li><li>Apart from that…</li><li>Finally…</li><li>Last but not least…</li></ol><h3 id="Vocabulary-for-the-conclusion-part"><a href="#Vocabulary-for-the-conclusion-part" class="headerlink" title="Vocabulary for the conclusion part:"></a>Vocabulary for the conclusion part:</h3><ol><li>In conclusion…</li><li>In summary…</li><li>To conclude…</li><li>To conclude with…</li><li>To sum up…</li><li>In general…</li><li>To summarise…</li><li>In short…</li><li>All in all…</li><li>Overall…</li><li>On the whole…</li><li>To draw the conclusion…</li><li>To elucidate…(‘To elucidate’ means - ‘make something clear’ or ‘to explain’.)</li><li>All things considered…</li><li>By and large…</li><li>Taking everything into consideration…</li><li>Taking everything into account…</li><li>Weighing up both sides of the argument…</li></ol><h3 id="Vocabulary-for-generalising-a-statement"><a href="#Vocabulary-for-generalising-a-statement" class="headerlink" title="Vocabulary for generalising a statement:"></a>Vocabulary for generalising a statement:</h3><ol><li>Generally…..</li><li>Generally speaking…..</li><li>In general…..</li><li>Basically…..</li><li>As a rule…..</li><li>Essentially…..</li><li>On the whole….</li><li>All things considered…..</li></ol><p>Examples:<br>1) All things considered, a certain reserved position for women in high-level jobs is actually a good idea to empower the women towards the overall betterment of the organisation and society.</p><p>2) In general, it can be stated that in upcoming few years human will be blessed with adequate facilities, which definitely will make their lives quite easier, due to advanced technology.</p><p>3) As a rule, in most of the countries, a zoological garden is monitored strictly and the health, treatment and food are properly ensured for the animals they keep.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;英语写作中的vacabulary总结。持续更新…&lt;/p&gt;
    
    </summary>
    
    
      <category term="English" scheme="http://hexiecs.com/categories/English/"/>
    
    
      <category term="英语" scheme="http://hexiecs.com/tags/%E8%8B%B1%E8%AF%AD/"/>
    
      <category term="写作词汇" scheme="http://hexiecs.com/tags/%E5%86%99%E4%BD%9C%E8%AF%8D%E6%B1%87/"/>
    
  </entry>
  
  <entry>
    <title>英语写作IDEA总结</title>
    <link href="http://hexiecs.com/2019/10/19/English/%E5%86%99%E4%BD%9CIDEA%E6%80%BB%E7%BB%93/"/>
    <id>http://hexiecs.com/2019/10/19/English/写作IDEA总结/</id>
    <published>2019-10-19T14:50:52.000Z</published>
    <updated>2019-12-03T00:47:06.843Z</updated>
    
    <content type="html"><![CDATA[<p>英语写作常见话题的idea、词汇、段落表达</p><a id="more"></a><h1 id="英语写作IDEA总结"><a href="#英语写作IDEA总结" class="headerlink" title="英语写作IDEA总结"></a>英语写作IDEA总结</h1><h2 id="Advertising"><a href="#Advertising" class="headerlink" title="Advertising"></a>Advertising</h2><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ol><li>现代商业的重要组成部分： Advertising is a key part of modern business</li><li>公司需要向顾客介绍他们的商品：Companies need to tell customers about their products</li><li>广告能够通知我们我们所拥有的选择：Advertisements inform us about the choices we have</li><li>广告是一个能够使很多人就业的创新行业： Advertising is a creative industry that employs many people</li><li>没有广告我们的选择就会更少： Without advertising we would have less choice</li><li>没有广告就会有更多的失业：Without advertising there would be higher unemployment</li><li>广告是现代艺术的一种形式：Advertising is a form of modern art</li><li>人们喜欢广告： People enjoy adverts</li></ol><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol><li>广告会控制人： Advertising manipulates people</li><li>它的目标是说服人们买一样商品可以让他们更快乐：It aims to persuade people that buying a product will make them happier</li><li>广告商专注于售卖对于商标的印象： Advertisers focus on selling a brand image</li><li>他们使用富有魅力的成功人士：They use glamorous, successful people</li><li>我们现在生活在消费文化中： We now live in a customer culture</li><li>我们被说服要追随最新的潮流： We are persuaded to follow the latest trend</li><li>我们被鼓励把某些商标和更高的社会地位联系在一起： We are encouraged to associate certain brands with a higher status</li><li>广告商常常把他们的市场针对孩子们：Advertisers ofter aim their markets at children</li><li>孩子很容易就会被广告影响：Children can be easily influenced by advertisements</li><li>孩子们会对父母造成压力来给他们买东西：Children put pressure on parents to buy them things</li><li>young people are easily influenced by television commercials</li><li>children will actually believe in the exaggerated claims frequently made in advertisements.</li><li>This is particularly serious in the case of adverts for products such as junk food that are actively unhealthy.</li><li>we are inundated with advertising in many different forms</li></ol><h3 id="观点"><a href="#观点" class="headerlink" title="观点"></a>观点</h3><ol><li>广告应该被规范: Advertising should be regulated</li><li>针对孩子的广告应该被控制甚至禁止： Advertising aimed at children should be controlled or even banned</li><li>不健康的食物不应该以一种吸引孩子的方式进行营销：Unhealthy food shouldn’t be market in a way that attracts children</li><li>会对健康造成影响的商品应该展示警告：Products that can be risky to healthy should display warnings</li><li>在一些国家在电视上展示香烟是违法的：In some countries it is illegle to advertise cigarettes on television</li><li>在香烟包上应该展示警告：warnings must be displayed on cigaretts packets</li><li>然而，广告对自由市场经济来说是必要的：However, advertising is neccesary in free market economies</li><li>它创造了对于商品的需要： It creates demand for products</li><li>政府只应该审查错误的信息或者是有害的商品： Goverment should only cersor false information or products that are harmful</li><li>most successful advertisements are in some way memorable</li><li>many adverts try to make the product or service seem glamorous</li><li>there is the category of the witty or humorous advert</li><li>there should be some regulation of advertising,but it is unclear who should be responsible for this and how the regulations should apply. </li><li>companies should be allowed to promote their products and services as they see fit.</li><li>there are surely some instances when it would be inappropriate for there to be no restrictions on advertising.</li></ol><h3 id="相关词汇"><a href="#相关词汇" class="headerlink" title="相关词汇"></a>相关词汇</h3><h4 id="广告的不同形式"><a href="#广告的不同形式" class="headerlink" title="广告的不同形式"></a>广告的不同形式</h4><p>television commercial（电视上的广告）, radio spot(电台的广告), billboard(路旁的公告牌)，flyer(传单, handout flyers), small ads/personal ads(个人自己的广告), trailer(预告片), product placement(植入广告)， promotion(促销), endorsement(名人的代言), sponsorship(赞助)</p><h4 id="描述广告的形容词"><a href="#描述广告的形容词" class="headerlink" title="描述广告的形容词"></a>描述广告的形容词</h4><p>witty/humorous(诙谐的，幽默的), memorable(印象深刻的), persuasive(有说服力的), misleading(误导的), word-of-mouth(有口碑的)</p><h4 id="其它相关词汇"><a href="#其它相关词汇" class="headerlink" title="其它相关词汇"></a>其它相关词汇</h4><p>regulation(监管), advertising agency(广告代理商)，target(目标)， consumers(顾客), brand awareness(品牌认知度) promote sb’s products, logos and slogans of companies,advertising agencies,make sth glamorous,endorse the product,follow suit， free market</p><h3 id="相关段落"><a href="#相关段落" class="headerlink" title="相关段落"></a>相关段落</h3><h4 id="children-and-advertisement"><a href="#children-and-advertisement" class="headerlink" title="children and advertisement"></a>children and advertisement</h4><p>Children nowadays are exposed to more and more adverts on television. Many people believe that this represents a problem because young people are easily influenced by television commercials. One danger this presents is that children will actually believe in the exaggerated claims frequently made in advertisements. This is particularly serious in the case of adverts for products such as junk food that are actively unhealthy.</p><h4 id="Different-forms-of-advertising"><a href="#Different-forms-of-advertising" class="headerlink" title="Different forms of advertising"></a>Different forms of advertising</h4><p>In the modern world, we are inundated with advertising in many different forms. There are, of course, the obvious examples such as television commercials,radio spots, billboards by the roadside and the neon signs that light up the cities at night. In addition to these, however, there are other less evident ways in which companies attempt to promote their products. For example, when you sit down to watch a football match, you will see the logos and slogans of companies that sponsor the shirts or even nowadays the stadium. Product placement works in much the same way in the cinema. You think you are sitting down to watch a film, but advertising agencies will make sure that their clients’ latest products are on display too.</p><h4 id="How-advertising-works"><a href="#How-advertising-works" class="headerlink" title="How advertising works"></a>How advertising works</h4><p>Advertising works in many different ways, but it is safe to say that most successful advertisements are in some way memorable. Unless we can remember what the advert was about it, it failed. Likewise, many adverts try to make the product or service seem glamorous: this may be achieved by getting a star from the world of entertainment to endorse the product. The idea is that if Brad Pitt says that he uses this shaving gel, then men all around the world will follow suit. Finally, there is the category of the witty or humorous advert - a clever advert can make the product itself seem “intelligent”, even when it is no more than a washing-up liquid.</p><h3 id="Regulation-of-advertising"><a href="#Regulation-of-advertising" class="headerlink" title="Regulation of advertising"></a>Regulation of advertising</h3><p>There is little doubt that there should be some regulation of advertising, but it is unclear who should be responsible for this and how the regulations should apply. One one level, in the free market, companies should be allowed to promote their products and services as they see fit. However, there are surely some instances when it would be inappropriate for there to be no restrictions on advertising. For example, tobacco and alcohol companies should not be allowed to buy advertising time on television and radio.</p><h2 id="Compare-advantages-and-disadvangages-of-media"><a href="#Compare-advantages-and-disadvangages-of-media" class="headerlink" title="Compare advantages and disadvangages of media"></a>Compare advantages and disadvangages of media</h2><h3 id="comics-漫画"><a href="#comics-漫画" class="headerlink" title="comics: 漫画"></a>comics: 漫画</h3><h4 id="advantages"><a href="#advantages" class="headerlink" title="advantages"></a>advantages</h4><ul><li>Comic books provide information in the most interesting and interactive way to the readers.</li><li>It is more efficient for kids who are yet to start reading big books.</li><li>Readers of comic books find it very easy to remember the information delivered by stories and cartoons in comics. It is less time consuming to read a comic.</li><li>Comics can transcend language and cultural boundaries.</li><li>Comic readers do not have to spend a lot of time on reading. This is preferred by many readers who do not like reading pages after pages.</li></ul><h4 id="disadvantages"><a href="#disadvantages" class="headerlink" title="disadvantages"></a>disadvantages</h4><ul><li>While reading comics readers often do not pay attention to the main information due to irrelevant cartoon or story.</li><li>It can be a waste of time for readers who wanted to receive useful information from comics.</li><li>Comic books are often published based on pure fiction and imagination and might have negative effects on the psychology of young kids.</li><li>However, because of the simplicity of comic books, they can only communicate short information.</li><li>Comics are not as much informative as books are.</li></ul><h3 id="books"><a href="#books" class="headerlink" title="books"></a>books</h3><h4 id="advantages-1"><a href="#advantages-1" class="headerlink" title="advantages"></a>advantages</h4><ul><li>Books are very instructive and effective in conveying information as they comprise the writer’s thought and life experience and are usually written over a longer period of time.</li><li>The book is a significant media to receive information ranging from basic skills to professional knowledge.</li><li>Reading books help us to nourish our mind and keep us moving forward in a positive direction.</li><li>A reader always has a wide range of choices to pick a book based on his/ her interest.</li><li>Books are everlasting while the basic formation of other media changes a lot over the time.</li><li>Readers pay more attentions while reading a book and that is why they can learn better from reading.</li><li>Reading books can give us an insight into many different cultures, and civilisations.</li><li>The secret to a successful life is knowledge and information. The answers to nearly all our problems and query are documented in texts somewhere.</li><li>Books can stimulate and excite a reader’s imagination as well as arouse his curiosity, thus bringing out the creative oneself.</li><li>Books help to articulate our thoughts and reading books improve our vocabulary and communication skill.</li><li>Reading the book is like peeking into the minds of the greatest people - A book is like a conversation with the writer and reading many books gives us an insight into the thinking process of different writers.</li><li>Intercultural understanding will be developed by reading more related books. Humans will become more familiar with demographic of nations as they read more books about them.</li><li>Individuals will have a better comprehension, grammar, communication skill, and more variety of vocabularies.</li><li>Readers always have a wide range of options to read books that would entertain and interest them.</li><li>Books are portable and people can access it from almost anywhere.</li></ul><h4 id="disadvantages-1"><a href="#disadvantages-1" class="headerlink" title="disadvantages"></a>disadvantages</h4><ul><li>Books are not always attractive to many people. For those people, books are not the greatest source of information and knowledge.</li><li>It required more patience and time to read books.</li><li>Book production requires cutting down trees, and that has a negative impact on our environment.</li><li>Information presented on books could be outdated in many cases.</li><li>Sometimes a writer can instil an ideology to a reader and can influence his thinking in a negative way.</li><li>People have to have a high level of literacy to read some specific and advanced books.</li></ul><h3 id="radio"><a href="#radio" class="headerlink" title="radio"></a>radio</h3><h4 id="advantages-2"><a href="#advantages-2" class="headerlink" title="advantages"></a>advantages</h4><ul><li>Accessible in anywhere and anytime, during driving or travelling.</li><li>Radio is less costly than the other media devices, like TV. Unlike TV, which users have to pay a monthly payment for cable, Radio does not need this cost.</li><li>It is available in the rural areas as well.</li><li>Have less detrimental issues.</li></ul><h4 id="disadvantages-2"><a href="#disadvantages-2" class="headerlink" title="disadvantages"></a>disadvantages</h4><ul><li>No access to any visual features which TV has.</li><li>Less being developed compared to TV or other media devices. Every year, new versions of TV, like introducing of smart TVs, have led users to be satisfied more, while there are no any significant changes in the technology of Radio.</li><li>Less accepted by the new generation.</li></ul><h3 id="film"><a href="#film" class="headerlink" title="film"></a>film</h3><h4 id="advantages-3"><a href="#advantages-3" class="headerlink" title="advantages"></a>advantages</h4><ul><li>Becoming familiar with other cultures by watching movies.</li><li>Watching films is a kind of entertainment. People have less stressful lifestyle by watching more films.</li><li>Some films improve viewers’ relationships. Family films are the best ones helping families to have a better communication.</li></ul><h4 id="disadvantages-3"><a href="#disadvantages-3" class="headerlink" title="disadvantages"></a>disadvantages</h4><ul><li>Cultural invasion can happen. Young’s minds are more affected by watching other countries’ films.</li><li>Addiction to watching film may be costly and time-consuming. We have to pay fees for Netflix or the cinema and have less enough time to concentrate on our work. </li><li>It can reduce juveniles’ study performance. Instead of studying, they spend their precious time on watching plenty of films each month.</li><li>Violence and sex scenes that are shown on movies can phenomenally increase the rate of crime among viewers.</li></ul><h2 id="Happiness"><a href="#Happiness" class="headerlink" title="Happiness"></a>Happiness</h2><ul><li>Happiness means different things to different people</li><li>It can be described as a feeling of pleasure or enjoyment</li><li>People can enjoy spending time with friends and family</li><li>Hobbies, sports and games can be a source of fun and enjoyment</li><li>Some people see money as a source of happiness</li><li>Other people define happiness as something deeper</li><li>In order to be true happy it is necessary to live a good life</li><li>We need to feel that we are doing something useful with our lives</li><li>Some people get a sense of achievement from their work</li><li>Other find happiness in bringing up their children</li><li>Religion or a sense of purpose can also be a source of happiness</li></ul><h3 id="范文"><a href="#范文" class="headerlink" title="范文"></a>范文</h3><p>Everybody desires to be happy in life and interestingly the requirements to be cheerful vary from person to person. This is the main reason why defining happiness is not that easy. However, there are some common things that are regarded important to be delighted in life.   </p><p>Defining happiness is quite challenging because the requirements to achieve it is not fixed. While someone dreams that his economic freedom would make him happy, a very rich man dreams about having a caring family to be happy. Similarly, a couple who do not have any child think about having a baby all the time and would be ready to do anything for that. On the contrary, many poor families, mostly in poor countries, find more children to be their burden. The practical world is quite puzzling and the humankind wants more than they have. When a person’s aim or expectation is fulfilled, he wants more and this is a never ending process. This is why happiness is not a simple word that we can describe with a neat and precise definition.</p><p>However, there are some vital factors that are commonly regarded as the main ingredients to be happy in life. First of all, physical and psychological soundness is very important to be happy and people can truly realise that when they get sick. Economic freedom - ability to fulfil the needs in life, is the second most important factor to be happy, in my opinion. It is often said that being happy with an empty stomach is not possible. Thirdly, having a happy family where members love each other and care for them is considered important to be in peace in life. It is usually rare to find a happy person who does not have a pleasant family. Individual freedom is also considered a great influence to be happy in life. Someone without personal freedom cannot feel the happiness. Most importantly, being contented in life is the key to being happy. If someone can be contented with whatever little he has, he will be happy in life.</p><p>In conclusion, though there is no easy and precise definition of happiness, common attributes like sound health, caring family, freedom and personal contentment are regarded to be key ingredients to be happy in life.</p><h2 id="手机和网络等新兴事物"><a href="#手机和网络等新兴事物" class="headerlink" title="手机和网络等新兴事物"></a>手机和网络等新兴事物</h2><p>Mobile phones and the Internet are two great innovations of science for communication and have been facilitating（使…便利） people for a long time. These two technologies are widely used in almost all the countries of the world and had become a part of our daily lives. We can’t deny the usefulness of these technologies as they had made our life easier than it was ever before. In my opinion, the advantages of these two devices far outweigh the demerits they have.</p><h2 id="大学"><a href="#大学" class="headerlink" title="大学"></a>大学</h2><p>Every human being with an ambition of getting higher knowledge requires attending colleges or universities. The main reason for attending universities or colleges may differ man to man. Someone may aspire to achieve greater knowledge, someone may just want to earn a certificate or someone might attribute it as a step towards career development.</p><h2 id="食物"><a href="#食物" class="headerlink" title="食物"></a>食物</h2><p>Compared with people in the past, we concern far less on the preparation of food today, thanks to the development of agriculture and scientific technology. A fair amount of beneficial influence is occurring to us consequently.</p><h2 id="家长和老师的作用"><a href="#家长和老师的作用" class="headerlink" title="家长和老师的作用"></a>家长和老师的作用</h2><p>I believe parents are always teaching us in many ways intentionally and unintentionally; however, the contributions teachers have in our learning process cannot be ignored.</p><h2 id="政府监管"><a href="#政府监管" class="headerlink" title="政府监管"></a>政府监管</h2><ul><li>Governments can censor what public sees or reads in the media </li><li>To a certain extent censorship is necessary</li><li>We should use censorship to protect children from violent images </li><li>Some computer games involve killing people or committing crimes </li><li>The Internet also needs to be controlled</li><li>Many websites show pornography and violence</li><li>There should be age limits for websites and computers games</li><li>Parents need to take responsibility for checking what their children watch </li><li>It is impossible for governments to control everything we see</li></ul><h2 id="性别对比"><a href="#性别对比" class="headerlink" title="性别对比"></a>性别对比</h2><h3 id="男性的优势科目"><a href="#男性的优势科目" class="headerlink" title="男性的优势科目"></a>男性的优势科目</h3><ul><li>it is obvious that there are more policemen than policewomen. Man can run faster, men are stronger and men can react to a dangerous situation more quickly. All of these points help men become more suitable to be the police. In this case, universities should have more male students in learning how to become a well-trained policeman in future, rather than female students.</li></ul><h3 id="女性优势科目"><a href="#女性优势科目" class="headerlink" title="女性优势科目"></a>女性优势科目</h3><ul><li>when it comes to the work of teaching in school,  especially primary school, it is no doubt that men can’t do as good as women. It is children’s nature that they always prefer to be taught by female teachers. They treat their female teachers as their close friends, sometimes even their mothers. Normally, comparing to men, women are more likely to understand what are the children thinking and what they really want. For example, if a child accidently hurt his thumb, his female teacher would hold him in her arms to comfort him. However, a female teacher may tell the child it’s not a big deal. For the teaching subject, apparently, universities should have more female students.</li></ul><h2 id="Gap-Year"><a href="#Gap-Year" class="headerlink" title="Gap Year"></a>Gap Year</h2><h3 id="advantage"><a href="#advantage" class="headerlink" title="advantage"></a>advantage</h3><ul><li>By visiting places, individuals will be exposed to diverse cultures, tradition and a wide variety of people and these visits are helpful for them to attain social knowledge. It aids in their higher studies; for instance, in conducting thesis related to practice. </li><li>prior working experience will be added as a good point when young people prepare for jobs since many companies prefer experienced staff membets.</li><li>have a broader view of life and better personal resources to draw on. They tend to be more independent, which is a very important factor in academic study and research, as well as giving them an advantage in terms of coping with the challenges of student life.</li></ul><h3 id="disadvantages-4"><a href="#disadvantages-4" class="headerlink" title="disadvantages"></a>disadvantages</h3><ul><li>Education process will be disrupted. As a result, young people may end up continuing working and never return to school or finding it hard to re-adapt to an academic environment.</li><li>as youngsters start to earn money through work, they may incline towards some bad habits such as smoking, alcohol consumption, drug addiction and so on.</li><li>making a trip for a long period may affect their finacial status if they run out of money which may indulge in  debts. </li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;英语写作常见话题的idea、词汇、段落表达&lt;/p&gt;
    
    </summary>
    
    
      <category term="English" scheme="http://hexiecs.com/categories/English/"/>
    
    
      <category term="英语" scheme="http://hexiecs.com/tags/%E8%8B%B1%E8%AF%AD/"/>
    
      <category term="写作" scheme="http://hexiecs.com/tags/%E5%86%99%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>Linux命令行学习</title>
    <link href="http://hexiecs.com/2019/09/12/Linux/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%AD%A6%E4%B9%A0/"/>
    <id>http://hexiecs.com/2019/09/12/Linux/Linux命令行学习/</id>
    <published>2019-09-12T13:46:52.000Z</published>
    <updated>2019-11-17T13:46:27.290Z</updated>
    
    <content type="html"><![CDATA[<p>常用的Linux命令总结，持续更新…</p><a id="more"></a><h2 id="单引号双引号"><a href="#单引号双引号" class="headerlink" title="单引号双引号"></a>单引号双引号</h2><p>单引号里面的当作纯字符串处理，双引号里面可以做变量扩展，比如下面的命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello=hi;echo &apos;$hello&apos;</span><br></pre></td></tr></table></figure><p>输出是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$hello</span><br></pre></td></tr></table></figure><p>而</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello=hi;echo &quot;$hello&quot;</span><br></pre></td></tr></table></figure><p>输出是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hi</span><br></pre></td></tr></table></figure><h2 id="任务管理"><a href="#任务管理" class="headerlink" title="任务管理"></a>任务管理</h2><p>Linux跟任务管理相关的符号和命令有&amp;, ctrl-z, fg, bg, jobs等。  </p><h3 id="amp"><a href="#amp" class="headerlink" title="&amp;"></a>&amp;</h3><p>在一个命令后加上&amp;表示将这个命令放到后台运行，不占用当前终端</p><h3 id="fg"><a href="#fg" class="headerlink" title="fg"></a>fg</h3><p>将一个任务带到前台运行，命令<code>fg 任务号</code></p><h3 id="bg"><a href="#bg" class="headerlink" title="bg"></a>bg</h3><p>将一个任务带到后台运行，命令<code>bg 任务号</code></p><h3 id="jobs"><a href="#jobs" class="headerlink" title="jobs"></a>jobs</h3><p>查看当前后台任务有哪些，任务号就是第一个数字。</p><h3 id="ctrl-z"><a href="#ctrl-z" class="headerlink" title="ctrl-z"></a>ctrl-z</h3><p>将当前的前台任务状态置为stop，并放到后台。</p><h2 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h2><h3 id="直接密码登录"><a href="#直接密码登录" class="headerlink" title="直接密码登录"></a>直接密码登录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -p port user@remoteip</span><br></pre></td></tr></table></figure><h3 id="密钥登陆"><a href="#密钥登陆" class="headerlink" title="密钥登陆"></a>密钥登陆</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen</span><br><span class="line">ssh-copy-id user@host</span><br><span class="line">ssh -p port user@remoteip</span><br></pre></td></tr></table></figure><h2 id="查看文件内容"><a href="#查看文件内容" class="headerlink" title="查看文件内容"></a>查看文件内容</h2><h3 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cat [-benstuv] [file ...]</span><br><span class="line">-b: 将非空行从1开始编号</span><br><span class="line">-e: 显示不可见字符，并将每行结尾显示为$</span><br><span class="line">-n: 将输出行从1开始编号，注意与-b的区别</span><br><span class="line">-s: 将多个相邻的空行压缩成一个</span><br><span class="line">-t: 显示不可见字符，并将tab显示为^I</span><br></pre></td></tr></table></figure><p>当不带file参数或带-时，cat会从标准输入读入，向标准输出</p><h3 id="less"><a href="#less" class="headerlink" title="less"></a>less</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-m: 显示百分比</span><br><span class="line">-N: 显示行号</span><br><span class="line">/字符串: 向下搜索字符串</span><br><span class="line">?字符串: 向上搜索字符串</span><br><span class="line">b: 向后翻一页</span><br><span class="line">d: 向后翻半页</span><br><span class="line">u: 向前翻半页</span><br><span class="line">y: 向前翻一行</span><br><span class="line">空格: 滚动一行</span><br><span class="line">回车： 滚动一页</span><br><span class="line">g: 移动到最后一行</span><br><span class="line">G: 移动到最后一行</span><br></pre></td></tr></table></figure><h3 id="head"><a href="#head" class="headerlink" title="head"></a>head</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-n 行数: 显示开头一些行</span><br><span class="line">-c 字节数:  显示开头一些字节</span><br></pre></td></tr></table></figure><h3 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-f: 循环读取</span><br><span class="line">-c 字节数：显示末尾的一些字节</span><br><span class="line">-n 行数：显示末尾的一些行</span><br></pre></td></tr></table></figure><h2 id="创建链接"><a href="#创建链接" class="headerlink" title="创建链接"></a>创建链接</h2><h3 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ln src dest</span><br><span class="line">src: 已存在的文件</span><br><span class="line">dest: 创建的硬链接文件</span><br></pre></td></tr></table></figure><p>硬链接即将这个文件的inode节点新增一个link，这个文件在磁盘上只有一份内容，但是可以有多个路径指向它的inode。当它的内容被改时，在多个路径都能同步。当src的文件被删时，这个文件也不会被真正的删除，因为inode的link数还大于0.<br>硬链接相对软链接有几个限制：</p><ol><li>不允许给目录建立硬链接</li><li>只有同一个文件系统中的两个文件才可以建立硬链接</li></ol><h3 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s src dest</span><br></pre></td></tr></table></figure><p>软链接没有硬链接的限制，对于软链接而言，并没有修改原文件的inode的link数，而是创建了一个新的文件，这个文件的内容是原文件的路径，所以其实和原文件是两个文件。当原文件被删除后，这个软链接也就失效了，因为它指向的不再是一个合法的路径。</p><h2 id="更改权限"><a href="#更改权限" class="headerlink" title="更改权限"></a>更改权限</h2><h3 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chown [选项]... [所有者][:[组]] 文件</span><br><span class="line">-R: 处理指定目录以及其子目录下的所有文件</span><br></pre></td></tr></table></figure><h3 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod ［who］ ［+ | - | =］ ［mode］ 文件名</span><br><span class="line">chmod ［mode］ 文件名</span><br></pre></td></tr></table></figure><p>who:</p><ul><li>u: 文件的owner</li><li>g: 文件的group</li><li>o: 其它人</li><li>a: 所有人</li></ul><p>mode: r,w,x</p><h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><h3 id="du"><a href="#du" class="headerlink" title="du"></a>du</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">du [选项][文件]</span><br><span class="line">-a: 显示目录中的所有文件和目录的大小</span><br><span class="line">-c: 显示目录的总大小</span><br><span class="line">-k: 以KB为单位</span><br><span class="line">-m: 以MB为单位</span><br><span class="line">-s: 只显示总计</span><br><span class="line">-h: 以KB,MB,GB为单位，提升可读性</span><br><span class="line">-d: 显示的目录深度</span><br></pre></td></tr></table></figure><h3 id="df"><a href="#df" class="headerlink" title="df"></a>df</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-h: 更易读的方式</span><br><span class="line">-H: 和-h类似，但是1k=1000而不是1024</span><br><span class="line">-i: 显示inode</span><br><span class="line">-m: 区块大小为1MB</span><br><span class="line">-T: 显示文件系统类型</span><br><span class="line">-t: 只显示指定文件系统</span><br></pre></td></tr></table></figure><h3 id="mount"><a href="#mount" class="headerlink" title="mount"></a>mount</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mount: 列出系统挂载的所有文件系统</span><br><span class="line">mount -t type: 只输出指定类型的文件系统</span><br><span class="line">mount spec dir: 把spec设备挂载到dir目录</span><br></pre></td></tr></table></figure><h2 id="网络管理"><a href="#网络管理" class="headerlink" title="网络管理"></a>网络管理</h2><p>ifconfig</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ifconfig: 获取或修改网卡配置</span><br><span class="line">ifconfig interface up</span><br><span class="line">ifconfig interface down</span><br><span class="line">启动关闭指定网卡</span><br></pre></td></tr></table></figure><h2 id="查找文件"><a href="#查找文件" class="headerlink" title="查找文件"></a>查找文件</h2><p>find</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">find [path...] [expression]</span><br><span class="line">path： 所查找的目录路径</span><br><span class="line">expression: 可分为-options, -print, -exec, -ok</span><br><span class="line">-options: 指定find命令的选项</span><br><span class="line">-print: 将匹配的文件输出到标准输出</span><br><span class="line">-exec：对匹配的文件执行此参数对应的shell命令</span><br></pre></td></tr></table></figure><p>常用的选项：</p><ul><li>-name：按照名字来查找文件，如: find . -name “*.cpp”</li><li>-prune: 使find命令不在当前指定的目录中查找.</li><li>-type<br>查找某一类型的文件，诸如：<br>b - 块设备文件。<br>d - 目录。<br>c - 字符设备文件。<br>p - 管道文件。<br>l - 符号链接文件。<br>f - 普通文件。 </li></ul><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sort : 按字典序</span><br><span class="line">sort -n : 识别为数字，按照数字大小排序</span><br><span class="line">sort -M : 识别为三字符的月份，按月份排序</span><br><span class="line">sort -t &apos;:&apos; -k pos : 按:分隔字段，并对第pos个字段排序</span><br><span class="line">sort -r: 降序排序</span><br><span class="line">du -sh *  | sort -nr : 对文件所占空间从大到小输出</span><br></pre></td></tr></table></figure><h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">grep -v</span><br><span class="line">grep -c : 输出多少行匹配了</span><br><span class="line">grep -n: 输出匹配的行号</span><br><span class="line">grep -e t -e f : 指定多个匹配的pattern</span><br><span class="line">grep [tf] : 正则，搜索t或f</span><br></pre></td></tr></table></figure><h2 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gzip file : 压缩文件</span><br><span class="line">gzcat : 查看压缩过的文件的内容</span><br><span class="line">gunzip: 解压文件</span><br><span class="line">gzip生成的压缩文件后缀为.gz</span><br></pre></td></tr></table></figure><h2 id="归档"><a href="#归档" class="headerlink" title="归档"></a>归档</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar cvf xxx.tar xxx/</span><br><span class="line">tar xvf xxx.tar</span><br></pre></td></tr></table></figure><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">coproc cmd</span><br><span class="line">在后台生成一个子shell用于执行cmd</span><br></pre></td></tr></table></figure><h2 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alias -p: 打印所有的alias</span><br><span class="line">alias cmd1=&apos;cmd2&apos;:  创建别名</span><br></pre></td></tr></table></figure><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">env: 打印所有的系统环境变量， 注意是系统的全局环境变量而不是用户自定义的局部环境变量</span><br><span class="line">printEnv: 打印某个环境变量</span><br><span class="line">set: 打印所有的环境变量</span><br><span class="line">variable=xxx: 定义一个局部环境变量，在子shell中不可见</span><br><span class="line">export variable: 将该环境变量export到全局，在子shell中也可见</span><br><span class="line">需要注意的是，在子shell中改变环境变量的值不会影响到父shell</span><br><span class="line">unset variable: 删除环境变量</span><br><span class="line">数组变量：mytest=(one two three four five)</span><br><span class="line">echo $&#123;mytest[2]&#125;</span><br></pre></td></tr></table></figure><h2 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">umask xxx : 指定默认创建的文件权限的掩码。文件的默认全权限是666，目录的默认全权限是777， 比如此时umask设置的是0022， 跟全权限取</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;常用的Linux命令总结，持续更新…&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://hexiecs.com/categories/Linux/"/>
    
    
      <category term="Linux命令行" scheme="http://hexiecs.com/tags/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C/"/>
    
  </entry>
  
  <entry>
    <title>C++多线程编程中的thread_local、volatile关键字</title>
    <link href="http://hexiecs.com/2019/09/09/C++/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84thread-local%E3%80%81volatile%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://hexiecs.com/2019/09/09/C++/多线程编程中的thread-local、volatile关键字/</id>
    <published>2019-09-09T12:55:37.000Z</published>
    <updated>2019-10-18T00:42:02.197Z</updated>
    
    <content type="html"><![CDATA[<p>最近在项目中用到了C++中的thread_local和volatile，写篇文章总结一下。</p><a id="more"></a><h2 id="thread-local"><a href="#thread-local" class="headerlink" title="thread_local"></a>thread_local</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>thread_local是C++11中新加的关键字，用于指定变量的存储周期（称为存储类指定符）。在C++11前，已经有几种存储类指定符，分别是：</p><ul><li>auto: 自动存储期与无链接</li><li>register： 自动存储期与无链接；不能取这种对象的地址</li><li>static - 静态存储期与内部链接（除非在块作用域）</li><li>extern - 静态存储期与外部链接（除非已声明带内部链接）</li></ul><p>c++11新增的:</p><ul><li>_Thread_local  - 线程存储期</li></ul><p>这里的thread_local其实是_Thread_local的一个宏，方便使用。thread_local可以和static或extern一起使用来决定变量的链接方式。上面四种存储期都比较简单，下面通过和static对比来介绍下thread_local对象：</p><ul><li>可以用static对象做对比来方便理解，static存储在全局，所有线程都共享，彼此的修改都会互相影响，因此在多线程中对static变量并发修改时需要加锁。static对象可以修饰全局变量、块局部变量，成员变量，当某个线程执行到static对象的定义语句时，会在全局为这个对象分配空间，以后不会再执行这个对象的定义语句。</li><li>而thread_local对象是每个线程都会独立拥有一份拷贝，可以想象成有一个map，把线程id映射到变量的拷贝。线程彼此的修改不会互相影响，所有线程都只会看到自己的那份拷贝，所以当多个线程需要对一个变量的修改进行共享时，不能用thread_local。同样的，thread_local也可以修饰全局变量、块局部变量和成员变量，和static变量不同的是，当某个线程执行到这个变量的定义语句，分配这个变量的存储空间后，别的线程同样会执行这个变量的定义语句来在本线程内分配存储空间。  </li></ul><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><h4 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">public:</span><br><span class="line">...</span><br><span class="line">private:</span><br><span class="line">...</span><br><span class="line">static thread_local int foo;</span><br><span class="line">&#125;;</span><br><span class="line">thread_local A::foo = 1;</span><br></pre></td></tr></table></figure><p>如上面的代码片段所示，thread_local可以用来修饰成员变量(加不加static都是一样的)，变量的初始化方式和static变量类似，需要在class外部进行初始化，每个线程都会初始化这个变量一次。</p><h4 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread_local int foo = 1;</span><br></pre></td></tr></table></figure><p>同样，每个线程都会初始化这个变量一次，每个线程都拥有对这个变量的独立拷贝。</p><h4 id="块作用域变量"><a href="#块作用域变量" class="headerlink" title="块作用域变量"></a>块作用域变量</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void Foo() &#123;</span><br><span class="line">static thread_local bar = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于每个线程，当它运行到这行定义语句时，都会创建一个独立的副本，和static变量一样，每个线程只初始化这个对象一次。</p><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>当试图用volatile来解决多线程程序的可见性问题时，99%的情况都是错误使用volatile。我在项目中看到很多多线程并发操作的代码片段都加上了volatile关键字，事实上这更多是一种心理安慰，去掉volatile不会对结果产生任何影响。首先回顾一下volatile能做出的几点保证：</p><ul><li>易变性：被volatile修饰的对象可能被意外的，不可预期的被改变，所以要求编译器每次读取该变量时都从内存中读取</li><li>不可优化性：禁止编译器优化掉跟这个对象相关的语句</li><li>顺序性：要求编译器保证volatile对象的语句之间是顺序的，但是没有保证volatile对象和非volatile对象的顺序，也没有保证cpu不对volatile语句乱序执行。</li></ul><p>大多数人看到易变性就会想到这个线程正在读取的变量正在被另一个线程修改，所以这个变量是易变的，然后试图用volatile关键字来让编译器每次读取这个变量时都从内存中读取而不是用寄存器来优化。<br>在这种场景下，一个线程在读一个变量的同时，另一个线程在写这个变量，这时候应该用锁或atomic来解决多线程对同一对象的竞争关系，因为即使这时候用volatile保证了是从内存中进行读取，由于多个线程在并发的对这个内存地址进行读写，这时候读到的数据可能是错的。 如果已经加了锁，那再加上volatile的唯一作用就是让程序运行的更慢了:) 因为锁已经可以保证这个变量是被一个线程独享了，并且在锁已经是一个内存屏障。<br>当然，如果这个变量只是一个int64的（在一个总线宽度内），cpu读写这个变量可以做到原子性，那这时候可不可以不加锁，直接用volatile来保证可见性就好了？我认为应该分情况讨论：</p><ul><li>共享变量的乱序是无所谓的，比如仅用于通知作用，考虑如下代码片段：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">volatile int stop = 0;</span><br><span class="line">// 线程1执行的函数</span><br><span class="line">void ThreadWork1() &#123;</span><br><span class="line">while (!stop) &#123;</span><br><span class="line">DoSomething();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//线程2执行的函数</span><br><span class="line">void ThreadWork2() &#123;</span><br><span class="line">stop = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果stop不加volatile，那么线程1可能会一直用寄存器中的值导致不能及时stop。所以volatile是适合用于多线程之间的简单的标志位的，但也仅限于作为一个标志位，如果这个标志位和其他的代码逻辑是耦合的，也就是说代码的乱序执行会对结果产生影响，那volatile是无能为力的，考虑如下的代码片段：</p><ul><li>共享变量的乱序执行会造成错误的结果：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">volatile int stop = 0;</span><br><span class="line">// 线程1执行的函数</span><br><span class="line">void ThreadWork1() &#123;</span><br><span class="line">while (!stop) &#123;</span><br><span class="line">DoSomething();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//线程2执行的函数</span><br><span class="line">void ThreadWork2() &#123;</span><br><span class="line">// DoSomething2会改变一些值，比如令a = 1， 而ThreadWork1里的DoSomething的逻辑又依赖于a = 1</span><br><span class="line">DoSomething2();</span><br><span class="line">stop = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这种情况下，由于编译器或cpu可能会乱序执行 stop = 1和DoSomething2，导致ThreadWork1里看到stop = 1时其实DoSomething2并没有执行，导致DoSomething里的逻辑错误。<br>对于大多数的代码而言，其实都是属于第二种情况，因此除非你真的确定代码的乱序执行不会对结果产生影响，否则不要在多线程的共享变量中使用volatile，改用锁或atomic即可完美的代替volatile，即使是第一种情况也是可以用锁或atomic来代替的。因此我们可以对volatile的使用场景做一个总结：</p><h3 id="volatile使用场景"><a href="#volatile使用场景" class="headerlink" title="volatile使用场景"></a>volatile使用场景</h3><ul><li>和信号处理（signal handler）相关的场合；</li><li>和内存映射硬件（memory mapped hardware）相关的场合；</li><li>和非本地跳转（setjmp 和 longjmp）相关的场合。</li><li>多线程中的简单标志位，简单指的是和其他代码的乱序执行不会对结果产生影响</li></ul><p>上面已经讨论了第四种情况，这里简单讨论前三种情况，事实上前三种情况是由于程序意想不到的地方改变了变量的值，导致需要读取内存，并且禁止编译器优化掉相关语句。比如在信号处理中，中断处理函数可能改了某个变量的内存内容，而原程序继续执行的时候，寄存器中的内存是旧的，因此需要重新从内存读取。而内存映射IO中，硬件的状态是随时可变的，比如同一个地址，可能每秒钟对应的硬件的状态都是不同的，而从同一地址读取两次可能会被编译器优化成一次，这时候编译器的优化就是错误的。在非本地跳转时，跳转后可能会修改变量，和信号处理的过程类似。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在项目中用到了C++中的thread_local和volatile，写篇文章总结一下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++" scheme="http://hexiecs.com/categories/C/"/>
    
    
      <category term="C++" scheme="http://hexiecs.com/tags/C/"/>
    
      <category term="thread_local" scheme="http://hexiecs.com/tags/thread-local/"/>
    
      <category term="volatile" scheme="http://hexiecs.com/tags/volatile/"/>
    
  </entry>
  
  <entry>
    <title>四个hexo next部署博客踩到的坑</title>
    <link href="http://hexiecs.com/2019/09/07/%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2/%E5%9B%9B%E4%B8%AAhexo-next%E9%83%A8%E7%BD%B2%E5%8D%9A%E5%AE%A2%E8%B8%A9%E5%88%B0%E7%9A%84%E5%9D%91/"/>
    <id>http://hexiecs.com/2019/09/07/博客部署/四个hexo-next部署博客踩到的坑/</id>
    <published>2019-09-07T14:35:04.000Z</published>
    <updated>2019-10-18T00:41:50.092Z</updated>
    
    <content type="html"><![CDATA[<p>总结一下部署博客遇到的坑，有遇到同样坑的可以借鉴一下</p><a id="more"></a><h2 id="next主题升级"><a href="#next主题升级" class="headerlink" title="next主题升级"></a>next主题升级</h2><p>刚开始用的是next5.1，最近打算升级成6.x，顺遍把界面风格给换一下。 我是按照<a href="https://github.com/theme-next/hexo-theme-next/blob/master/docs/zh-CN/UPDATE-FROM-5.1.X.md" target="_blank" rel="noopener">next官网上顺滑升级的步骤</a>操作，具体步骤是</p><ol><li>把6.x的next clone到一个新的名字比如next-reloaded</li><li>把旧的next文件夹里的主题配置拷过去</li><li>把hexo里的theme改为next-reloaded</li></ol><p>hexo g的时候就报错了，包括但不限于:</p><ol><li>hexo next can’t find lodash merge</li><li>Object.values is not a function</li><li>Cannot read property ‘enable’ of undefined</li></ol><p>期间我以为是hexo和node的版本太低了，因此又卸载了node和hexo，全都重新安装，结果还是会报同样的错。在卸载node又重装时又遇到‘/usr/local/bin/node: No such file or directory’，这个错误是通过下面几个步骤解决的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. brew uninstall --force node</span><br><span class="line">2. brew uninstall --force npm</span><br><span class="line">3. brew install node</span><br><span class="line">4. brew link --overwrite node</span><br></pre></td></tr></table></figure><p>但是上面几个错误依然存在，最后折腾两天还是不行后，彻底放弃平滑升级，直接重建用hexo部署了一个博客目录，然后把原来的文章拷过来才解决的。</p><h2 id="hexo-init-npm-install很慢"><a href="#hexo-init-npm-install很慢" class="headerlink" title="hexo init/npm install很慢"></a>hexo init/npm install很慢</h2><p>通过 <a href="https://www.jianshu.com/p/26640fbad18e" target="_blank" rel="noopener">这个链接</a>提供的方法解决</p><h2 id="评论系统"><a href="#评论系统" class="headerlink" title="评论系统"></a>评论系统</h2><p>以前的博客用的是多说，但后来多说关了，这次打算尝试下来必力，但由于众所周知的原因，来必力的加载太慢了，所以放弃了来必力，改为valine，没想到valine的成功部署也费了不少功夫。本来next 6.x已经内置支持了valine，只需要把_config.yml里的valine的enable = true，然后把appid和appkey填成leancloud里的相应字段就行，但我填好后valine评论就是显示不出来，看控制台也没有报错。最后发现有以下几个坑:</p><ol><li>在next主题的_config.yml里是用的app_id和app_key这两个字段，而在<code>themes/next/layout/_third-party/comments/valine.swig</code> 代码里判断的是appid和appkey，所以需要把_config.yml里的app_id和app_key改为appid和appkey</li><li>leancloud里的设置里有个安全中心，里面需要把自己网站的域名配置到安全域名里，注意这里不用添加网站的端口号</li><li><code>themes/next/layout/_third-party/comments/valine.swig</code> 这个文件本身也需要修改，具体改动看<a href="https://github.com/iissnan/hexo-theme-next/pull/1983" target="_blank" rel="noopener">这个github issue</a><br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6rcvx4pajj310c0re7ah.jpg" alt></li></ol><h2 id="hexo-wordcount没有单位"><a href="#hexo-wordcount没有单位" class="headerlink" title="hexo wordcount没有单位"></a>hexo wordcount没有单位</h2><p>hexo wordcount统计出来的字数和阅读时长都是不带单位的，可以参考<a href="https://www.jianshu.com/p/baea8c95e39b" target="_blank" rel="noopener">这篇文章</a>加上单位。<br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6rczrqi2uj313m0p0wie.jpg" alt> </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结一下部署博客遇到的坑，有遇到同样坑的可以借鉴一下&lt;/p&gt;
    
    </summary>
    
    
      <category term="博客部署" scheme="http://hexiecs.com/categories/%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2/"/>
    
    
      <category term="hexo next" scheme="http://hexiecs.com/tags/hexo-next/"/>
    
      <category term="博客部署" scheme="http://hexiecs.com/tags/%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2/"/>
    
  </entry>
  
  <entry>
    <title>Bigtable论文笔记</title>
    <link href="http://hexiecs.com/2019/05/12/Distribute/Bigtable%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    <id>http://hexiecs.com/2019/05/12/Distribute/Bigtable论文笔记/</id>
    <published>2019-05-12T08:54:00.000Z</published>
    <updated>2019-09-07T11:14:47.839Z</updated>
    
    <content type="html"><![CDATA[<p>Bigtable论文的笔记</p><a id="more"></a><h1 id="Bigtable论文笔记"><a href="#Bigtable论文笔记" class="headerlink" title="Bigtable论文笔记"></a>Bigtable论文笔记</h1><h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><p><code>(row:string, column:string, timestamp:int64) -&gt; string</code><br>一个Bigtable就是一个多维的排序map，其中row和column类似于关系型数据库中的概念。<br>对于row有几点特别的：</p><ul><li>在同一行的读写都是原子的，而跨行的读写并不是原子的。  </li><li>行按字典序排序  </li><li>连续的一些行称为一个tablet，是负载均衡的基本单位。  </li></ul><p>对于column有一点特别的：  </p><ul><li>多个列key可以被划分到一个列族中，列族是权限控制的基本单位，并且同一个列族的数据类型是一样的，因此数据可以基于列被压缩。  </li></ul><p>timestamp：  </p><ul><li>时间戳使得Bigtable可以存储同一数据的多个版本，还可以基于时间戳进行垃圾回收，比如只保留几天的数据，只保留几个版本的数据等等。</li></ul><h2 id="系统组成"><a href="#系统组成" class="headerlink" title="系统组成"></a>系统组成</h2><ul><li>client library</li><li>一个master server，负责分配tablets给tablet server，监测tablet server的增加和退出，tablet server的负载均衡，GFS中文件的垃圾回收。还负责schema的改变，比如表和column的创建。  </li><li>tablet server管理许多tablets，直接负责tablets的读写和分裂。</li></ul><h2 id="Tablet位置"><a href="#Tablet位置" class="headerlink" title="Tablet位置"></a>Tablet位置</h2><p>Bigtable用一个类似于B+树的三层结构来存储tablet的位置信息，如图所示。</p><p><img src="/images/Distribute/B1.png" alt></p><ol><li>root tablet的位置存放在Chubby中，root tablet中包含了METADATA table中的所有tablet的位置信息。其实root tablet就是METADATA table的第一个tablet，但是它永远不会分裂。  </li><li>METADATA table的每一行存储一个tablet的位置信息，row key是这个tablet所在的表的标识符和这个tablet的最后一行两者的encoding。</li><li>METADATA tablet的每一行大概有1KB的数据，假设一个METADATA tablet有128MB，那么这个三层结构可以索引2^34个tablet(每个tablet有2^17行，那么root tablet可以索引2^17个METADATA tablet，而每个METADATA tablet又可以索引2^17个实际的数据tablet)。</li></ol><p>client library会缓存tablet的位置信息，如果client的缓存是正确的，那直接根据缓存的信息寻址即可，否则这里分为两种情况讨论：</p><ol><li>client的缓存是空的<br>这时候client需要依次去chubby，root tablet server，metadata tablet server去拿位置信息，总共3个rtt</li><li>client的缓存是错误的<br>讨论最坏情况，client缓存的metadata tablet信息和root tablet信息都是错的。client会依次进行以下步骤：<br>2.1 先根据缓存的metadata tablet信息去访问对应的tablet，发现位置是错的<br>2.2 client去metadata tablet server拿新的tablet位置信息，发现metadata tablet server的位置信息也是错的。<br>2.3 client去root tablet server拿metadata tablet的最新位置信息，发现root tablet server的位置也是错的<br>2.4 client去chubby拿最新的root tablet server位置信息<br>2.5 client去root tablet server拿最新的metadata tablet server信息<br>2.6 client去metadata tablet server拿最新的tablet位置信息<br>最坏情况下总共花了6个rtt  </li></ol><h2 id="Tablet分配"><a href="#Tablet分配" class="headerlink" title="Tablet分配"></a>Tablet分配</h2><p>master负责跟踪tablet server的运行情况，以及tablets到tablet server的分配情况。当一个tablet没有被分配时，master会向一个可用的tablet server发送一个tablet load请求来分配该tablet。<br>Bigtable使用Chubby来跟踪tablet server，当tablet server启动时，会向chubby申请一个互斥锁（其实是chubby某个目录下的一个文件）。当tablet server失去锁时就会停止服务，当这个锁文件已经被删后，这个tablet server再也不能对外服务，因此它就自己退出了。<br>master通过周期性的问tablet server它们的锁状态来检测它们的运行情况，当tablet server报告自己失去了锁，master就会去chubby尝试获取相同的锁，如果成功了，说明chubby是正常的，而这个tablet server要么挂了，要么是连不上chubby，因此master就可以把这个tablet server的文件给删了，把这个tablet server负责的tablets分配给其他tablet server。<br>当master启动时，它需要发现当前tablet的分配情况，master启动时的运行步骤如下：  </p><ol><li>在chubby获取master锁，防止并发的master启动</li><li>master扫描chubby中的tablet server的目录，获取当前存活的server</li><li>master和每个存活的server通信，发现已经分配的tablets</li><li>master扫描METADATA table来发现所有的tablets，当遇到还未分配的tablets时，就把它加入到未分配的集合中</li></ol><p>在第4步扫描METADATA table前，METADATA tablets需要被分配，因此master在进行第4步前会先将root tablets分配，而root tablets包含所有的METADATA tablets的名字，master进而可以知道METADATA tablets的分配情况。<br>tablet的集合在几种情况下会变化：</p><ul><li>table被创建或删除</li><li>两个tablet被merge成一个更大的tablet</li><li>一个tablet被分裂成两个</li></ul><p>前两种情况都是由master发起的，最后一种情况直接由tablet server发起。tablet server在分裂时会通知master，如果这个通知丢失了（比如master或者tablet server挂了），master在后来让tablet server加载已经分裂的tablet时也会知道这一点。这个tablet server会通知master，因为它在METADATA table中找到的tablet只是master让它加载的tablet的一部分（说明这个tablet已经分裂了而master还不知道）。  </p><h2 id="Tablet-Serving、Compaction"><a href="#Tablet-Serving、Compaction" class="headerlink" title="Tablet Serving、Compaction"></a>Tablet Serving、Compaction</h2><p>和leveldb原理相同</p><h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><h3 id="局部组"><a href="#局部组" class="headerlink" title="局部组"></a>局部组</h3><p>其实就是列式存储，个人认为Bigtable最大的贡献就是它的数据模型和列式存储了。Client可以将多个列族指定到一个局部组中，这个局部组的数据会被一个单独的SSTable文件存储。将数据按列进行存储使得读更加高效，因为当指定读某一列的数据时不用读很多没用的数据。<br>除此之外，局部组还有一些有用的参数，比如可以指定某一个局部组是常驻内存的，这样的话读的时候就不用访问磁盘，比较适合经常访问的少量的数据。</p><h3 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h3><p>Client可以控制一个局部组是否被压缩，压缩是作用于每个SSTable Block而不是整个文件，这样虽然会损失一些空间但是在读取的时候可以不用解压整个文件。</p><h3 id="缓存提高读性能"><a href="#缓存提高读性能" class="headerlink" title="缓存提高读性能"></a>缓存提高读性能</h3><p>为了提高读性能，tablet server使用两级的缓存。扫描缓存是把SSTable接口返回给tablet server的key value对缓存。块缓存是把从GFS读取的SSTable块缓存起来。扫描缓存对于重复读相同数据的的应用很有用，而块缓存对于倾向于读附近位置的数据的应用很有用。</p><h3 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h3><p>读操作必须要读取组成一个tablet的所有SSTable，如果这些SSTable都在磁盘的话，就会涉及到多次磁盘访问。通过指定布隆过滤器可以显著减少访问次数，因为布隆过滤器可以告诉我们一个key是否存在于SSTable中，如果不存在，就没必要再去磁盘读取了。这个事实也说明，大多数对于不存在的行或列的查找都是不需要访问磁盘的。</p><h3 id="commit-log实现"><a href="#commit-log实现" class="headerlink" title="commit-log实现"></a>commit-log实现</h3><p>如果每个tablet都独立有一个commit log的话，就会有非常多的文件并发的写入GFS，这会造成大量的磁盘访问。除此之外，独立的log文件也减少了group commit优化的效果。为了解决这个问题，Bigtable把所有的修改都提交到一个单独的commit log文件。<br>使用单独的commit log文件显著的提高了正常操作的性能，但是使恢复过程复杂了。当一个tablet server挂掉时，它负责的tablet会被分配给许多其它的tablet server，为了恢复一个tablet，新的tablet server需要加载之前的tablet server的commit log，但是这些tablets的commit log都被混合在一起。即使每个tablet server只应用对应tablet的那一部分，这个commit log文件也会被读很多次。<br>为了避免读log file很多次，首先将commit log按照key的字典序排序，排序后，某个tablet的所有entry都是连续的，因此只需要一个disk seek和一次顺序读就好了。为了并行排序，在排序的时候把log file分为64MB的段，然后分给tablet servers进行归并排序，排序由master进行协调，在某个tablet server表明它需要从log file文件进行恢复时被初始化。  </p><h3 id="加速tablet恢复"><a href="#加速tablet恢复" class="headerlink" title="加速tablet恢复"></a>加速tablet恢复</h3><p>当master把tablet从一个tablet server移到另一个时，源server会先做一个minor compaction来减少commit log中未compact的log entry数目。然后这个源server就停止服务这个tablet（这里新的server还未加载这个tablet，所以这时这个tablet是由谁负责没搞明白），这时候源server再做一次compaction来把上次做minor compaction期间新增的log entry给compact了，这时候新的server就可以加载这个tablet了并且不存在任何未compact的log entry。  </p><h3 id="利用不变性"><a href="#利用不变性" class="headerlink" title="利用不变性"></a>利用不变性</h3><p>因为SSTable的不可改变的特性，Bigtable的许多设计都简化了。比如，当读SSTable时，不需要任何的访问同步。唯一可变的数据结构是memtable，通过让每个memtable行copy-on-write的方式，使得读和写可以并发进行。<br>因为SSTable是不变的，所以去掉被删除的数据可以被转变为垃圾回收过期的SSTable。<br>最后，SSTable的不变性使得我们可以快速的分裂tablets，对于每个子tablet不用生成新的SSTable，可以和父tablet共享SSTable。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Bigtable论文的笔记&lt;/p&gt;
    
    </summary>
    
    
      <category term="Distribute" scheme="http://hexiecs.com/categories/Distribute/"/>
    
    
      <category term="Distribute" scheme="http://hexiecs.com/tags/Distribute/"/>
    
      <category term="Storage" scheme="http://hexiecs.com/tags/Storage/"/>
    
  </entry>
  
  <entry>
    <title>Chubby分布式锁服务总结</title>
    <link href="http://hexiecs.com/2019/05/03/Distribute/Chubby%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E6%9C%8D%E5%8A%A1%E6%80%BB%E7%BB%93/"/>
    <id>http://hexiecs.com/2019/05/03/Distribute/Chubby分布式锁服务总结/</id>
    <published>2019-05-03T13:44:00.000Z</published>
    <updated>2019-09-06T15:34:36.293Z</updated>
    
    <content type="html"><![CDATA[<p>Chubby分布式锁服务总结</p><a id="more"></a><h1 id="Chubby分布式锁服务总结"><a href="#Chubby分布式锁服务总结" class="headerlink" title="Chubby分布式锁服务总结"></a>Chubby分布式锁服务总结</h1><p>Chubby是很经典的分布式锁服务，趁最近有空读了一下论文，大部分篇幅都是在讲艰苦的工程上的优化和权衡，主要是为了提供可靠性和简单的语义，其中会话和fail-over的设计比较复杂，本文主要是总结一下我认为值得注意的地方。</p><h2 id="设计目的"><a href="#设计目的" class="headerlink" title="设计目的"></a>设计目的</h2><ol><li>提供粗粒度的分布式锁，比如leader选举、服务发现。</li><li>提供小数据的可靠存储</li><li>重点关注可靠性、一致性、扩展性而不是性能，一致性依靠paxos解决。</li><li>提供简单的语义 </li></ol><h2 id="Paxos库-VS-分布式锁服务"><a href="#Paxos库-VS-分布式锁服务" class="headerlink" title="Paxos库 VS 分布式锁服务"></a>Paxos库 VS 分布式锁服务</h2><p>一个重点的设计考虑是到底应该提供一个paxos库来为client解决分布式锁的一致性问题（假设client的服务能实现为状态机。。），还是直接提供一个高可用的分布式锁服务。作者给了应该提供锁服务的原因：  </p><ol><li>大多数服务在刚开始写的时候并没有考虑高可用，当服务的规模越来越大时，程序员才会考虑高可用。等服务改造的时候，直接调用分布式锁服务会比改造为使用一个一致性协议要简单。  </li><li>许多服务在选主或在许多组件之间划分数据的时候有广播结果的需求，所以应该给client提供一个存储和获取少量数据的服务。这个可以通过一个名字服务来完成，但是锁服务本身就可以完成这个任务，并且还可以复用一致性协议的代码，因此Chubby提供了存储小数据的能力。  </li><li>当然对程序员来说，锁比paxos状态机要简单多了（讽刺的是，大多数程序员对分布式锁的理解都有问题，很少人会考虑到异步通信环境下的机器失败的问题）。  </li><li>分布式一致性协议依靠quorum来做决定，使用多个副本来保证高可用，比如Chubby很多时候使用5副本。如果Client使用Chubby的话，即使它只有一台机器存活，也可以安全的使用锁），也就是client本身不需要做到多台机以及quorum，一致性由chubby来提供。而如果Client使用一个一致性的库的话，它自己就得有多台机器，并且保证大多数存活才能继续。  </li></ol><h2 id="细粒度锁-VS-粗粒度锁"><a href="#细粒度锁-VS-粗粒度锁" class="headerlink" title="细粒度锁 VS 粗粒度锁"></a>细粒度锁 VS 粗粒度锁</h2><p>细粒度锁指的是只会持有锁很短的时间（秒级或更短），而粗粒度锁指的是持有比较长的时间，比如说是用于选主，通常都会是几小时甚至几天。这两种粒度的锁对锁服务提出了不同的要求。<br>粗粒度的锁因为隔很长的时间才需要访问锁服务一次，所以对server端的负载压力很小，并且这个负载跟client端的处理速率关联很小（意思是即使client端每秒处理很多请求，锁服务的server端收到的请求速率也不会明显增加）。另外，锁服务server端的机器故障对client的影响也比较小。<br>相对的，细粒度的锁就完全相反了，server端的失败可能造成很多client阻塞。性能和扩容的能力都很重要，因为server端的负载和client的处理速率密切相关。<br>Chubby只试图提供粗粒度的锁，但是client端可以利用Chubby很容易的实现自己的细粒度的锁。一个应用程序可以把自己的细粒度的锁进行分组，然后利用Chubby把这些细粒度锁的组分配到应用自己的一些服务器上。这样做最大的好处是，client端对支撑自己的负载应该需要多少服务器负责了，并且不用自己去实现一致性协议的部分。  </p><h2 id="系统结构"><a href="#系统结构" class="headerlink" title="系统结构"></a>系统结构</h2><p><img src="/images/Distribute/C1.png" alt></p><p>Chubby这里是使用paxos协议来保证一致性的，通常使用5个副本，读写请求都由master来完成。如果一个副本挂了，并且几个小时都没有恢复，一个另外的替换系统就会选一台新机器，启动lock server的二进制，然后更新DNS table。master会定期从DNS table拉数据，就会得知这个变化，然后在数据库中更新cell成员的列表，这个列表也是通过普通的一致性协议在副本间维护一致性的。同时，这个新的机器会从一个文件服务器和其他的活跃副本那里拉一个当前数据库的备份，等这个机器成功处理了master的一个等待commit的请求后（说明此时数据已经是最新了），这个机器就可以参与投票了。</p><h2 id="文件、目录和handles"><a href="#文件、目录和handles" class="headerlink" title="文件、目录和handles"></a>文件、目录和handles</h2><p>Chubby的命名空间和Unix的文件系统基本一样，这个有个好处是Chuuby内的文件即可以被Chubby自己的API访问，也可以被其他的文件系统比如GFS的API访问，这可以复用很多工具的代码。<br>有临时和永久的节点，所有节点都可以被显示的删除，临时节点当没有client打开它们时就会被自动删除，所以临时的节点可以被用来检测client是否存活。<br>权限控制：每个节点有3个ACLs名字来控制读、写、更改ACLs的权限。ACLs本身就是一个文件，放在一个ACL目录里。这些ACLs文件由简单的名字列表组成，比如，文件F的写名字是foo，ACL目录下有一个文件的名字就是foo，这个文件里有一个叫bar的项，所以用户bar就被允许写文件F。因为Chubby的ACLs是简单的文件，所以可以被其它想用类似机制的服务所复用。<br>handle，和Unix文件描述符类似，包括三个组成部分：  </p><ul><li>检查位： 防止client伪造handles，因此完整的访问控制检查只需要在创建handle的时候做。  </li><li>序列号：让master可以知道这个handle是不是旧的master产生的。</li><li>模式信息： 在创建时提供，可以在一个master接收到旧的master创建的handle时重建这个handle的状态。  </li></ul><h2 id="强制锁-VS-建议锁"><a href="#强制锁-VS-建议锁" class="headerlink" title="强制锁 VS 建议锁"></a>强制锁 VS 建议锁</h2><p>强制锁指的是当client没有持有锁时资源就不可用了，而建议锁指的是只有其它client想要持有同样的锁时才会产生冲突，持有锁对于访问资源来说并不是必要的。Chubby采用的是建议锁，理由如下：  </p><ul><li>Chubby锁常常保护其它服务的资源，而不是Chubby中跟锁关联的文件，而使用强制锁往往意味着要对其它服务做额外的修改。  </li><li>当用户需要访问锁住的文件进行调试或管理目的时，我们并不想用户关掉程序。  </li><li>我们的开发者使用很常见的错误检测方式，写assert语句比如‘assert 锁X被持有了’，所以强制锁的方式对他们来说意义不大。<br>在分布式系统中锁是复杂的，因为消息是不确定的，进程也可能会挂掉。举个例子，一个进程持有一个锁L，然后发起一个请求R，然后挂掉。另一个进程就会去持有这个锁L，然后在R到达前做一些操作。等R到达后，它可能就会在没有锁L的保护下进行操作，潜在的会造成不一致的数据。这里的意思是这个锁L保护了一段数据data，按理说这个R应该在这个data上进行操作的，但是由于进程挂掉，导致另一个进程修改了这个data，所以R就可能在不一致的数据上进行操作。<br>Chubby提供了一种在使用锁的时候使用序列号的方法来解决这个问题。在每次获得锁后都会请求一个序列号（其实是一个不可读的描述锁状态的字符串），client在发送请求的时候，会把这个序列号发给服务端，服务端会检测这个序列号的合法性。服务端可以通过和Chubby之间维护的cache来检测这个序列号的合法性，或者是直接和自己最近观测到的序列号比较（这里应该隐藏了一个假设，就是同一个cell的请求会路由到同一个服务器）。<br>尽管序列号机制很简单，但是有些协议发展的很慢，不能带上序列号，chubby因此提供了另一种不完美但是更容易的方式来解决这个问题。如果一个client是以正常的方式释放锁的，那么这个锁立刻可以被其他的client获得，但是如果一个锁是因为client挂掉或不可访问而丢掉的，锁服务器会等一段叫lock-delay的时间来防止其它的client获得这个锁。</li></ul><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>Chubby的client端可以订阅一些事件，这些事件通过回调的方式异步发送给client。</p><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>Chubby使用的是一致性的、write-through缓存。当文件数据或元数据被修改时，server端会阻塞住修改请求，然后向所以的client cache发出invalidate命令，这个invalidate命令是通过KeepAlive RPC的响应来完成的。client端收到Keep Alive响应后会马上使缓存失效，然后马上发起下一次Keep Alive RPC，顺带确认自己已经使缓存失效了。Server端在收到所有client的确认或者是client端的缓存租约过期后，才会继续这个阻塞的修改请求。<br>Chuuby还会缓存锁，也就是client会缓存锁比真正需要的时间更长，因为预期同一个client还会使用这个锁。当另一个client请求同样的锁时，锁持有人能得到通知，因此有机会释放这个锁。</p><h2 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h2><p>会话是Chubby Cell和Client端通过KeepAlive握手维护的一种关系，当会话有效时，client端的handle，锁，缓存都是有效的。<br>当client第一次连接cell时，它会请求一个新的会话，当client结束时会显示的终止会话，或者当这个会话一分钟内没有调用和打开handle时，也会被隐式的关闭。<br>每个会话都有个对应的租约，master承诺在租约内不会单向的关闭会话，master可以延长这个租约，但不能减少。收到KeepAlive后，master会阻塞这个RPC，直到client的租约接近过期，然后master会允许这个RPC返回，就可以通知client新的租约超时时间。master可以任意扩展租约超时，默认是12s，但是过载的master可以指定更大的值来减少KeepAlive RPC的数量。client在收到响应后，就会马上发起一个新的KeepAlive，因此几乎总是有一个KeepAlive被阻塞在master。<br>除开用来扩展租约之外，KeepAlive还被用来传递事件和缓存失效给client。如果事件或者缓存失效发生了，master允许KeepAlive立刻返回。在KeepAlive RPC的响应中附带上事件确保client在没有确认缓存失效前不能维护会话，<br>client维护了自己的一个本地租约超时时间，是master租约超时的近似。之所以还要维护一个本地的，是因为KeepAlive RPC在网络上传递还需要时间，并且master的时钟速率跟client也不相同，所以client需要对这两个因素作出保守的估计。时钟速率这里，主要担心的是server端的时间走的太快，比如租约是12s，client端这里以为刚走了6s，server端那里已经12s了，这样的话server端已经把会话给关闭了client端也不会知道，就会造成不一致。因此文章里说server端的时钟和client端的时钟相比不会比一个已知的常数更快，client端就可以据此作出估计。<br>当client端租约超时时，就会进入一种jeopardy状态，再等一段称为grace period的时间后client端才会真正的认为这个会话超时了。在这期间，如果client端和server端成功的进行了一次KeepAlive RPC的话，会话就再次进入正常状态。<br>Chubby的client库可以通知应用程序jeopardy事件，当会话恢复正常时，会通知应用程序safe事件，当会话超时时，会通知应用程序超时事件。这些信息使应用程序可以知道会话的状态，在不确定会话是否关闭时可以停下来等一会儿，如果只是个临时性的问题的话，就可以自动恢复而不用重启应用。这避免了应用重启的巨大开销。  </p><h2 id="Fail-overs"><a href="#Fail-overs" class="headerlink" title="Fail-overs"></a>Fail-overs</h2><p>在master挂掉的时候，如果master选举很快，那client可以在自己的本地超时过期前就联系上新的master；否则，client的本地超时过期后，client可以利用grace period来让会话在fail-over期间得以维持，也就是说，grace period其实增加了client端的租约超时时间。<br><img src="/images/Distribute/C2.png" alt><br>图2是client端在master fail-over时利用grace period来保留会话的一个例子。从图中可以看到client的本地租约已经超时，client进入了jeopardy状态，在grace period期间，client成功的联系上了新的master。一旦client成功联系上新master，对应用程序而言，就像是没有失败发生一样。为了实现这个，新master必须要重建旧master的内存状态，一个新选举出来的master需要进行的流程：  </p><ol><li>首先选一个新的client epoch号，client需要在每个调用中带上这个epoch号。master会拒绝使用旧epoch号的client端，这可以防止新master对一个很老的发送给旧master的包作出响应。  </li><li>新master可能会对master-location请求作出响应，但不会对跟session有关的请求作出响应。  </li><li>新master根据数据库中持久化的信息在内存中构建锁和会话的数据结构，会话的租约被扩展到之前的master可能已经使用的最大值。  </li><li>master现在允许client执行KeepAlive  </li><li>给每个会话生成一个fail-over事件，使client端刷新缓存，因为client可能错过了缓存失效事件，并且警告应用程序其它事件可能也丢掉了。（因为旧master挂的时候可能还来不及发送各种事件就挂了）。  </li><li>master等待client端确认fail-over事件或者是client端的会话超时。  </li><li>master允许所有的操作正常进行。  </li><li>如果client使用一个旧的handle，新的master会在内存中构建这个handle的状态。如果这个重建的handle后续被关了，master也会在内存中记录下来，使得在这个master的任期内不可能再重新创建一个相同的handle。  </li><li>在一段时间后，master会把没有handle打开的临时文件给删了，因此client端需要在这段时间内刷新自己对临时文件的handle。这个机制有个不好的地方是在fail-over期间如果一个临时文件的所有client端都失去了会话，这个临时文件也不能及时被删除（需要等这段时间结束，通常是1min）。</li></ol><h2 id="扩展性"><a href="#扩展性" class="headerlink" title="扩展性"></a>扩展性</h2><p>一个chubby master可能会和非常多的client直接通信，因此最有效的扩展机制是减少和master之间的通信，而不是提升请求处理的速度。chubby使用了几个方法：  </p><ul><li>创建任意多的chubby cell，使得chubby client可以直接和附近的cell进行通信。  </li><li>master在负载很重时可以增加租约超时时间，使得可以减少KeepAlive RPC的数目。KeepAlive RPC是目前请求中占最大部分的，对于一个过载的机器来说，不能及时处理KeepAlive RPC是最常见的错误，因为client对其它的请求耗时基本都不太敏感。  </li><li>chubby client缓存</li><li>使用协议转换服务器来将chubby的协议转换成更简单的协议，比如DNS和其它的一些协议。<br>文中介绍了两个常用的机制，代理和分区，使得chubby可以进一步扩展。<h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3>chubby的协议可以被代理，通过受信任的进程把请求从client端发送给server端。代理可以通过处理Keepalive请求和读请求来减少server端的负载，但是没办法减少写的流量。但是写流量对chubby的正常负载占比不到1%。如果一个proxy处理N个client，那KeepAlive的流量能够减少N倍。proxy cache能够减少读流量程度取决于读共享的平均数量，一般大约是10。不过读流量对chubby的负载占比不到10%，因此KeepAlive的流量减少是重要的多的。<br>代理对于写和第一次读都会增加一次RPC，因此不可用的概率至少是之前的两倍，因为每个代理的client现在都依赖两个机器：代理和master。<h3 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h3>命名空间可以根据目录进行分区，每个分区都有自己的副本和master，并且前提是跨分区的通信相当少。</li></ul><h2 id="fail-over时的问题"><a href="#fail-over时的问题" class="headerlink" title="fail-over时的问题"></a>fail-over时的问题</h2><p>master fail-over最开始的设计是master在新会话创建时把会话写进数据库中，但是当许多进程同时启动时，这就会造成过载。为了避免这个，server端杯修改成不是在创建时把会话写进数据库，而是在会话第一次尝试修改，锁获取或者打开文件时。另外，在KeepAlive时，会有一定的概率把会话写进数据库。因此，对于只读会话而言，写开销就会随着时间被分散了。<br>这个修改带来的一个问题是，只读会话可能不会被写进数据库，因此在fail-over时就会被忽略。如果所有被记录的会话都成功的跟新master取得了联系（这里指的是都成功确认了fail-over事件），那mater就不会等一个额外的租约超时时间，如果这时候这个只读会话的租约还未超时，那它就可能读到一个旧的数据。虽然在实际系统中，这不太可能发生，因为在fail-over时，几乎总是有会话不能成功的和新master取得联系。尽管如此，fail-over还是修改了设计来避免这个影响。<br>在新设计下，不会在数据库中记录会话信息，而是像重建handle一样重建会话。新master现在会等一个最坏情况下的完整超时时间后才会允许操作进行，因为它不知道是否所有的会话都已经成功的确认了fail-over事件。  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Chubby分布式锁服务总结&lt;/p&gt;
    
    </summary>
    
    
      <category term="Distribute" scheme="http://hexiecs.com/categories/Distribute/"/>
    
    
      <category term="Distribute" scheme="http://hexiecs.com/tags/Distribute/"/>
    
      <category term="Lock" scheme="http://hexiecs.com/tags/Lock/"/>
    
  </entry>
  
  <entry>
    <title>Raft协议的一些思考</title>
    <link href="http://hexiecs.com/2018/12/02/Distribute/Raft%E5%8D%8F%E8%AE%AE%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/"/>
    <id>http://hexiecs.com/2018/12/02/Distribute/Raft协议的一些思考/</id>
    <published>2018-12-02T02:28:00.000Z</published>
    <updated>2019-09-06T15:34:36.294Z</updated>
    
    <content type="html"><![CDATA[<p>Raft协议的一些思考</p><a id="more"></a><h1 id="Raft协议的一些思考"><a href="#Raft协议的一些思考" class="headerlink" title="Raft协议的一些思考"></a>Raft协议的一些思考</h1><h2 id="什么一致？"><a href="#什么一致？" class="headerlink" title="什么一致？"></a>什么一致？</h2><p>一致性协议都是为了保证所有的节点状态是一致的，而一致的日志输出到状态机就可以产生一致的状态，所以只需要保证日志是一致的。</p><h2 id="怎么保证？"><a href="#怎么保证？" class="headerlink" title="怎么保证？"></a>怎么保证？</h2><h3 id="简化问题"><a href="#简化问题" class="headerlink" title="简化问题"></a>简化问题</h3><p>首先明确一下适用的场景：异步网络通信环境，非拜占庭错误。设想一种理想情况，没有节点宕机和网络分区发生。这样保证起来就会很简单，所有的请求都发给leader，leader把日志都同步给follower后，将日志提交到状态机。由于所有的follower都是复制的同一个leader的日志，自然大家都是一致的。然而现实情况不会这么完美，在分布式系统中节点宕机，网络分区是常态，所以我们要解决可能出现的问题。</p><h3 id="现实情况下会出现什么问题"><a href="#现实情况下会出现什么问题" class="headerlink" title="现实情况下会出现什么问题"></a>现实情况下会出现什么问题</h3><ol><li>leader出故障了</li><li>follower出故障了</li><li>网络分区了  </li></ol><p>下面分别阐述Raft是怎么解决这三个问题的</p><h3 id="1-leader出故障了"><a href="#1-leader出故障了" class="headerlink" title="1.leader出故障了"></a>1.leader出故障了</h3><p>这是最复杂的情况，会影响选主和日志的同步</p><h4 id="选主"><a href="#选主" class="headerlink" title="选主"></a>选主</h4><p>由于我们在上面说的理想情况下，follower都是复制的leader的日志，所以我们必须保证集群中任何时刻都存在leader，并且期望有且只有一个，因为leader大于1个时，日志就出现冲突了。 当leader出故障时，必然就需要重新选一个leader，所以Raft就设计了选主的算法，具体算法直接看论文就可以了。这里提出几个问题：  </p><ol><li>为什么要设置任期号?<br>任期号在Raft中(以及其它的一些一致性协议中)非常重要，它其实代表了当前节点的状态是否足够新，因为我们总是认为新的更为准确。在分布式环境中，节点可能会收到彼此冲突的消息，那选哪个呢，就选任期号大的，所以在发动选举时，就会将任期号加一来保证新的leader会被识别为更新的。  </li><li>什么时候leader会大于1个，怎么处理?<br>当网络分区时，就可能出现leader大于1个的情况，普通的网络分区比较简单，比如A,B和C，D，E出现了分区。这里讨论一种稍微复杂的情况，比如当前有A,B,C,D,E五台机，A为leader，此时A和B二者的网络出现分区，但是A,C,D,E以及B,C,D,E都可以正常通信，由于B超过一定时间没有收到leader的心跳，这时候B的term+1，发起新的选举，然后分两种情况:1.在B选举之前，A向C,D,E写了新的日志，那这时候B的日志不是最新的，选举永远不会成功，相当于此时集群中A,C,D,E会正常对外服务，leader不变 2.在B选举之前，A没有写新的日志，由于B的term更大，所以C，D，E会投票给B，这时候B成为新的leader，在此刻集群中出现了A,B两个leader，但A发出的请求不会被多数派通过(因为C,D,E的term更大)，所以对外是一致的。A在向C,D,E发心跳包的时候，从响应中可以知道自己的term落后了，就降为follower。然后，A也有可能再按照B的方式发起选举，这样就周而复始不断选举，造成很大的网络开销，这个可以通过pre-vote解决。所以即使出现了两个leader，Raft也可以保证确定log的时候不会有冲突。<h4 id="日志同步"><a href="#日志同步" class="headerlink" title="日志同步"></a>日志同步</h4>论文列举了几种leader和follower的日志不一致的情况，但除了(a)，本质原因都是由于这个follower以前是leader，当有未提交的日志时挂了，等恢复成follower的时候，就跟当前的leader日志不一致了。当出现不一致时，Raft采取的做法是用Leader的日志覆盖Follower的日志。这里提出几个问题：  </li><li>为什么leader将某个log entry设为commited之后，这个log entry之前的所有log，包括其他leader的log，都是可提交的?<br>因为日志匹配特性，某个日志是commit，说明leader和大多数节点在这条日志以及这条日志之前的日志都是相同的，因此都是可以提交的。  </li><li>leader完整特性怎么证明？有什么作用?<br>证明：虽然论文上的证明比较长，但可以由日志匹配特性直接得出leader完整特性，假设leader1不包含之前的某个leader2已经commit的日志，而如果这条commit的日志是最后一条日志，那这个leader1因为日志不够新不会赢得选举;如果这条日志<br>不是最后一条日志，那leader1的最后一条日志在被append的时候（那时候leader1还是follower），就会被当时的leader发现leader1中间缺失了一条commit日志，append就会失败。<br>作用：由于每个leader都包含之前的term被commit的所有日志，就意味着不管leader怎么改变，已经commit的日志不会丢，所以输入到状态机的日志就是一致的，保证了状态机安全特性。</li><li>为什么需要日志匹配特性？<br>日志匹配特性的目的有两个：一是为了得到leader完整特性，二是保证如果一个log entry可以commit了，那它之前的entry都是可以提交的。第二个目的让leader可以顺序的commit日志，进而状态机也可以顺序的apply日志，简化了处理逻辑。 假设我们可以放弃这两个目的(比如ParallelRaft)，比如通过其他措施来保证leader完整特性和状态机的安全特性，那我们就可以放弃日志匹配特性，那follower每次AppendEntry的时候就不用等待前面的entry都Append，就可以提高系统的整体吞吐。</li></ol><h3 id="2-follower出故障了"><a href="#2-follower出故障了" class="headerlink" title="2.follower出故障了"></a>2.follower出故障了</h3><p>只要出问题的follower小于总节点数量的一半，整个Raft Group就能正常工作。由于不一致时，follower会用leader的日志覆盖自己的，所以不管follower出什么问题，leader会对follower不断重试，只要在恢复时通过RPC将follower的日志恢复成leader的即可。</p><h3 id="3-网络分区"><a href="#3-网络分区" class="headerlink" title="3.网络分区"></a>3.网络分区</h3><p>网络分区可能会导致脑裂问题，在选主的第3个问题讨论了网络分区对选主的影响。同时，网络分区还可能会导致stale read, 可以通过ReadIndex Read和Lease Read的方法来解决，具体参考<a href="https://pingcap.com/blog-cn/lease-read/这篇文章。" target="_blank" rel="noopener">https://pingcap.com/blog-cn/lease-read/这篇文章。</a></p><h2 id="Multi-Raft"><a href="#Multi-Raft" class="headerlink" title="Multi-Raft"></a>Multi-Raft</h2><p>数据量大的时候，单个Raft实例负载太高，为了提高整体吞吐，往往将数据分为多个片，每个片由独立的Raft Group来管理。会有一个类似于元数据服务器的东西来管理所有的Raft Group，负责数据的分片，Group间的负载均衡等，难点引用<a href="https://zhuanlan.zhihu.com/p/33047950" target="_blank" rel="noopener">Elasticell-Multi-Raft实现</a>这篇文章提到的：</p><blockquote><ol><li>数据何如分片</li><li>分片中的数据越来越大，需要分裂产生更多的分片，组成更多Raft-Group</li><li>分片的调度，让负载在系统中更平均（分片副本的迁移，补全，Leader切换等等）</li><li>一个节点上，所有的Raft-Group复用链接（否则Raft副本之间两两建链，链接爆炸了）</li><li>如何处理stale的请求（例如Proposal和Apply的时候，当前的副本不是Leader、分裂了、被销毁了等等）</li><li>Snapshot如何管理（限制Snapshot，避免带宽、CPU、IO资源被过度占用）</li></ol></blockquote><p>具体可以参考上面这篇文章看看他们是怎么解决这些问题的</p><h2 id="ParallelRaft"><a href="#ParallelRaft" class="headerlink" title="ParallelRaft"></a>ParallelRaft</h2><p>这是在阿里的PolarFS中提出的对Raft在高I/O场景下的一种改进。具体来说就是Follower可以乱序确认，leader可以乱序提交，状态机可以乱序应用。<br>乱序确认是指Follower可以不管日志匹配特性，直接确认，所以我认为<a href="https://mp.weixin.qq.com/s/4s7lDKlQjV1mUoVv558Y7Q" target="_blank" rel="noopener">面向云数据库，超低延迟文件系统PolarFS诞生了</a>这篇文章中提到的ParallelRaft继承了Raft的LogMatching特性应该是有问题的，因为如果是乱序确认是没法满足LogMatching的。但是日志匹配特性的不满足就会导致leader完整特性的不满足，所以ParallelRaft用了另外的手段来满足leader完整特性，就是在leader选举的时候将leader中的log空洞给补上，这里感觉和multi-paxos很像。日志匹配特性的不满足还会带来的另一个问题就是一个entry变为commited之后，并不代表它之前的entry都可以commit了，因此leader的提交注定也是乱序的。状态机这里接收到一个log entry，如果发现它之前的entry不在的话当然可以一直等，直到把空洞补齐。但ParallelRaft采用了一种叫look behind buffer的数据结构来提高apply entry的并行度，每个log entry都记录自己前面的N个entry的修改情况（follower接收到的entry是乱序的，但leader生成entry的时候肯定是有序的，所以leader在生成一个entry的时候肯定知道了它前面的N个enty的修改情况）。look behind buffer记录每个entry修改的LBA（逻辑块地址），如果修改的块有重叠就代表有冲突，就需要等待，否则就可以乱序执行。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Raft协议的一些思考&lt;/p&gt;
    
    </summary>
    
    
      <category term="Distribute" scheme="http://hexiecs.com/categories/Distribute/"/>
    
    
      <category term="Distribute" scheme="http://hexiecs.com/tags/Distribute/"/>
    
      <category term="Consensus Algorithm" scheme="http://hexiecs.com/tags/Consensus-Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Cohort Query Processing论文笔记</title>
    <link href="http://hexiecs.com/2018/11/11/Database/Cohort%20Query%20Processing/"/>
    <id>http://hexiecs.com/2018/11/11/Database/Cohort Query Processing/</id>
    <published>2018-11-11T14:37:00.000Z</published>
    <updated>2019-09-06T15:34:46.248Z</updated>
    
    <content type="html"><![CDATA[<p>VLDB2017论文”Cohort Query Processing”</p><a id="more"></a><h1 id="Cohort-Query-Processing论文笔记"><a href="#Cohort-Query-Processing论文笔记" class="headerlink" title="Cohort Query Processing论文笔记"></a>Cohort Query Processing论文笔记</h1><p><a href="http://www.vldb.org/pvldb/vol10/p1-ooi.pdf" target="_blank" rel="noopener">论文链接</a></p><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>传统的数据库进行群体分析(cohort analysis)代价比较高，因为涉及到多张表的很多条记录。这篇文章提出了一种扩展的数据库系统来支持群体分析。通过对SQL扩展了3个新操作来实现的，并且设计了三种不同的群体分析请求处理的机制，其中两种采用了非侵入式的方法，第三种方式是为群体分析特别优化过的基于列存储(columnar)的机制。</p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>通过一个例子介绍了Cohort Analysis的好处，它能比直接分析一大堆数据得到更多的信息。群体分析：一种数据分析手段，能够得到在变化的社会环境中年龄对人类行为的影响，它允许我们把社会的改变和年龄分开，因此能提供更多信息。<br>cohort analytics中，分为3步：1）把用户分为群体 2）决定用户群体的年龄 3）计算每个群体的聚集。 第1步实施被称为cohort的操作来捕获社会不同的影响。社会科学家选择一个特定的动作e（被称为初始动作），基于用户执行这个动作e的时间（称为初始时间）把用户划分成不同的群体。一个用户的每个活动记录然后被赋予给这个用户属于的相同cohort。第2步，把每个cohort基于age划分成更小的子分区。一个记录t的age是这条记录和初始时间的间隔。最后，对每个cohort进行聚集行为。<br>然后作者举了一个游戏记录的例子来详细的说明第1步是怎么回事。<br>传统的群体分析有两个限制：1）分析整个数据集，因此没有机制能够提取一部分用户或记录来进行分析 2）只能使用时间属性来区分群体。此外，作者还举了几个例子说明传统的群体分析会受到限制。<br>这篇文章的贡献：  </p><ul><li>在DBMS的语义下定义了群体分析的问题  </li><li>介绍了一种模型化用户活动数据的扩展的群组分析方法，介绍了三个新的操作符可以用于扩展的关系和组成群体分析查询语句。  </li><li>构建了群体分析查询引擎，COHAHA，为群体分析实现了多种优化  </li><li>为比较COHANA和非侵入式的机制设计了基准测试研究<h2 id="群体分析的一种非侵入式方法"><a href="#群体分析的一种非侵入式方法" class="headerlink" title="群体分析的一种非侵入式方法"></a>群体分析的一种非侵入式方法</h2>作者举了一个群体分析的例子，然后用sql语句实现。可以看出用了很多join，性能低下，并且sql很复杂。即使采用MV的方法，也有一些问题，包括性能、存储空间、扩展性等等。<h2 id="群体分析基础"><a href="#群体分析基础" class="headerlink" title="群体分析基础"></a>群体分析基础</h2><h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h3>活动数据的集合称为活动关系的实例，也称为活动表。<br>一个活动表D是一个关系，包含属性Au，At，Ae，A1,…,An。Au是一个字符串唯一标识一个用户，Ae表示动作，At表示Au执行Ae的时间。其它属性都是标准的关系属性。并且，活动表D在（Au，At，Ae）上有主键限制。<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3>三个核心概念：初始动作（birth action）, 初始时间（birth time） 和年龄（age）.给定一个动作，初始时间是第一次执行这个动作的时间。一个动作e被称为初始动作，如果它被用来定义用户的初始时间。<h3 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h3>提出了两个新的操作符用来获得活动记录的子集，一个聚集操作符用来聚集每个（cohort，age）组合。<h4 id="操作符-1"><a href="#操作符-1" class="headerlink" title="操作符"></a><img src="http://wx1.sinaimg.cn/mw690/0060lm7Tly1fuviiuafvfj302g01ya9y.jpg" alt>操作符</h4></li></ul><p>这是个初始记录选择操作符，用来获得初始活动记录满足条件C的用户的活动记录。<br>比如我们想获得初始时在Australia执行launch动作的用户的活动记录，就可以这样写<br><img src="http://wx2.sinaimg.cn/mw690/0060lm7Tly1fuviotnmfrj30em02kjrg.jpg" alt></p><h4 id="操作符-2"><a href="#操作符-2" class="headerlink" title="操作符"></a><img src="http://wx4.sinaimg.cn/mw690/0060lm7Tly1fuvipsobc5j302o01wdfq.jpg" alt>操作符</h4><p>年龄选择操作符用来从活动表中返回所有的初始活动记录以及符合条件C的年龄活动记录。</p><h4 id="操作符-3"><a href="#操作符-3" class="headerlink" title="操作符"></a><img src="http://wx2.sinaimg.cn/mw690/0060lm7Tly1fuvitpdn6ej303o028wee.jpg" alt>操作符</h4><p>这个操作符产生群体聚集用两步：1）用户分群体 2）聚集活动记录。<br>第一步，把用户划分成群体，基于用户初始活动记录在指定属性集合上的映射。<br>在例子中，假设launch是初始动作，属性集合是{country}，玩家1，2，3都根据country属性的值被赋给不同的cohort。<br>在第2步，对于每个可能的群体和年龄的组合，选择属于的用户的关联的年龄活动记录，然后执行聚集函数。  </p><h3 id="操作符的属性"><a href="#操作符的属性" class="headerlink" title="操作符的属性"></a>操作符的属性</h3><p>第1，2个操作符满足交换律，因此我们可以把birth选择操作在查询中往下压，来优化查询。</p><h3 id="群体查询"><a href="#群体查询" class="headerlink" title="群体查询"></a>群体查询</h3><p>给定一个活动表D和上述三个操作符，一个查询可以表示成上述三个操作符的组合，这些操作符的birth action都是一样的。一个群体查询可以表示成下面的形式：<br><img src="http://wx4.sinaimg.cn/mw690/0060lm7Tly1fuvki9mjsrj30q805ut9f.jpg" alt></p><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>群体查询的方案可以在很多方面扩展，首先，可以把上述查询的结果和sql语句混合。另一个扩展是引入二元操作符(比如join，intersection)来操作多张表。</p><h3 id="群体查询操作符到SQL语句的映射"><a href="#群体查询操作符到SQL语句的映射" class="headerlink" title="群体查询操作符到SQL语句的映射"></a>群体查询操作符到SQL语句的映射</h3><p>展示了怎么把操作符用SQL语句表示</p><h2 id="COHANA查询引擎"><a href="#COHANA查询引擎" class="headerlink" title="COHANA查询引擎"></a>COHANA查询引擎</h2><p>为了用新设计的群体操作符支持群体分析，我们呈现了4种基于列存储的数据库的扩展：1）一个良好调节的水平存储格式用来持久化活动表 2）一个修改的表扫描操作符能够跳过不符合用户的年龄活动记录 3）一种cohort操作符的原生高效的实现 4）一个查询策划器能够利用cohort操作符的特性。</p><h3 id="活动表存储格式"><a href="#活动表存储格式" class="headerlink" title="活动表存储格式"></a>活动表存储格式</h3><p>用主键(Au,At,Ae)的顺序存储活动表的记录，这种存储布局有两个好的特性：1）相同用户的记录聚集在一起 2）每个用户的记录按照时间顺序存储。有这两个特性，我们可以高效的找到任何用户的任何初始动作的初始活动记录，只需要顺序扫描就好了。<br>我们采用了分块机制和多种压缩技术来加速cohort查询处理。首先把活动表水平分区成多个数据块，每个用户的活动记录被包含在恰好一个块中（这一步怎么做的还不清楚？）。然后，在每个数据块，活动记录按列存储。对于一个数据块中的每一列，我们基于列类型选择合适的压缩机制。<br>对于用户列Au，采用Run-Length-Encoding机制，也就是：Au的值被存储成三元组序列（u, f, n），u是Au中的用户，f是u在这一列第一次出现的位置，n是出现的次数。我们会看到采用这种方法，修改的表扫描器能够高效的跳过不符合条件的用户活动记录。<br>对于字符串列，采用一种两级的压缩机制。对于这样的列A，首先构建一个全局的字典，包含了A中出现的所有值，并且已经排好序和唯一化。A中的每个值都有一个全局id，代表这个值在字典中的位置。对于每个数据块，在这个块中的A的值的全局id构建成这个块的字典。这种两级的压缩机制使得可以高效的剪掉没有任何用户执行初始动作的数据块。对于一个给定动作e，首先用二分找到全局id，再把这个id在数据块字典中二分查找，找不到的话就可以跳过这个块了。<br>对于整数列也采用相似的二级压缩方法。<br>用上述的压缩方法，使得字符串和整数列都可以用整数数组来表示，因此可以用整数压缩技术来减少存储空间。具体思想是每个整数都采用固定长度的字节存储，这样支持高效的随机读写。</p><h3 id="群体查询的求值"><a href="#群体查询的求值" class="headerlink" title="群体查询的求值"></a>群体查询的求值</h3><p>这一节讲了怎么对一次查询请求求值。首先，生成一个逻辑的查询计划并对它进行优化，然后对每个数据块执行优化后的请求，最后合并每个块的结果。<br>我们介绍的查询计划由4个操作符组成，包括TableScan和上面说的3种操作符。跟其它基于列的数据库一样，映射操作是在预处理中做的：在请求准备阶段收集要求的列并把列传给TableScan操作符，来得到每列的值。<br>在查询计划中，根节点是聚集操作符，唯一的叶子节点是TableScan操作符。在他们之间是初始选择操作符和年龄选择操作符。<br>根据等式1，我们把初始选择操作符尽可能的下压，来优化查询。因为我们可以在4.3节看到，特别设计的TableScan实现可以高效的跳过那些初始活动记录不满足选择条件的用户的年龄活动记录。因此，尽可能的早做初始选择可以优化查询。<br>然后，我们利用Ae列的两级压缩机制来跳过没有用户执行初始动作e的数据块，然后对每个数据块执行查询。  </p><h3 id="TableScan操作符"><a href="#TableScan操作符" class="headerlink" title="TableScan操作符"></a>TableScan操作符</h3><p>我们为高效的群体分析处理扩展了标准的TableScan操作符。修改过的TableScan在压缩后的列上扫描，主要扩展了两个函数:GetNextUser()和SkipCurUser(). GetNextUser返回下一个用户的活动记录，SkipCurUser()跳过当前用户的活动记录。<br>TableScan实现如下:对于每个数据块，在查询初始话阶段，TableScan收集所有在请求中用到的列，并对每个列维护一个文件指针，初始时都指向列的起始位置。<br>GetNextUser()的实现：首先获取Au列的下一个三元组，然后让每个文件指针都向前走这个三元组相对于用户u的偏移。(注：这里因为是列存储的数据库，所以同一列的数据是顺序存放的，得到Au列的偏移后，其它列加上这个偏移就可以得到对应用户那行的数据)<br>SkipCurUser()的实现相似，当被调用时，首先计算当前用户剩余元组的个数，然后让指针前进相应的长度。  </p><h3 id="Cohort算法"><a href="#Cohort算法" class="headerlink" title="Cohort算法"></a>Cohort算法</h3><p>这一节开发了cohort操作符在提出的存储格式上的实现的算法。<br>第一个介绍的是初始选择操作符。没什么新奇之处，首先找到一个用户的初始元组，然后判断它满不满足条件，不满足的话调用SkipCurUser跳过当前用户，满足的话调用GetNext返回当前用户的元组，当取完后调用GetNextUser拿到下一个用户的数据块继续判断。<br>年龄选择操作符类似。<br>聚集操作符的实现。聚集操作符的含义是根据用户的初始活动元组在指定属性集上的映射来聚集用户的元组，并可以对每个年龄活动记录执行fA函数。实现时，维护两个hash表，一个装群体的大小，一个装群体的每个年龄(cohort,age)的聚集结果。  </p><h2 id="性能研究"><a href="#性能研究" class="headerlink" title="性能研究"></a>性能研究</h2><p>略</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;VLDB2017论文”Cohort Query Processing”&lt;/p&gt;
    
    </summary>
    
    
      <category term="Database" scheme="http://hexiecs.com/categories/Database/"/>
    
    
      <category term="Paper" scheme="http://hexiecs.com/tags/Paper/"/>
    
      <category term="Database" scheme="http://hexiecs.com/tags/Database/"/>
    
  </entry>
  
</feed>
